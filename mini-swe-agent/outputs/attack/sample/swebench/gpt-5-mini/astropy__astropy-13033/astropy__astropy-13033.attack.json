{
  "info": {
    "total_observations": 5,
    "python_observations": 0,
    "text_observations": 5,
    "ast_operators_applied": 0,
    "text_perturbation_applied": 3,
    "skipped": 2
  },
  "perturbations": [
    {
      "action": "ls -la && grep -R \"class TimeSeries\" -n testbed || true",
      "original": "total 672\ndrwxrwxrwx  1 root root   4096 Sep 10 09:24 .\ndrwxr-xr-x  1 root root   4096 Nov 29 03:28 ..\n-rw-r--r--  1 root root      0 Sep 10 09:22 .astropy-root\ndrwxrwxrwx  2 root root   4096 Sep 10 09:22 .circleci\ndrwxrwxrwx  8 root root   4096 Sep 10 09:26 .git\n-rw-r--r--  1 root root     16 Sep 10 09:22 .gitattributes\ndrwxrwxrwx  4 root root   4096 Sep 10 09:22 .github\n-rw-r--r--  1 root root   1218 Sep 10 09:22 .gitignore\n-rw-r--r--  1 root root  19977 Sep 10 09:22 .mailmap\n-rw-r--r--  1 root root   2056 Sep 10 09:22 .pep8speaks.yml\n-rw-r--r--  1 root root   2799 Sep 10 09:22 .pre-commit-config.yaml\ndrwxrwxrwx  3 root root   4096 Sep 10 09:22 .pyinstaller\n-rw-r--r--  1 root root    425 Sep 10 09:22 .readthedocs.yml\n-rw-r--r--  1 root root 507755 Sep 10 09:22 CHANGES.rst\n-rw-r--r--  1 root root     66 Sep 10 09:22 CITATION\n-rw-r--r--  1 root root    139 Sep 10 09:22 CODE_OF_CONDUCT.md\n-rw-r--r--  1 root root   9569 Sep 10 09:22 CONTRIBUTING.md\n-rw-r--r--  1 root root    129 Sep 10 09:22 GOVERNANCE.md\n-rw-r--r--  1 root root   1496 Sep 10 09:22 LICENSE.rst\n-rw-r--r--  1 root root    703 Sep 10 09:22 MANIFEST.in\n-rw-r--r--  1 root root   4558 Sep 10 09:22 README.rst\ndrwxrwxrwx 24 root root   4096 Sep 10 09:26 astropy\ndrwxr-xr-x  2 root root   4096 Sep 10 09:24 astropy.egg-info\n-rw-r--r--  1 root root   4140 Sep 10 09:22 azure-pipelines.yml\ndrwxrwxrwx  5 root root   4096 Sep 10 09:22 cextern\n-rw-r--r--  1 root root     13 Sep 10 09:22 codecov.yml\n-rw-r--r--  1 root root   2568 Sep 10 09:22 conftest.py\ndrwxrwxrwx 25 root root   4096 Sep 10 09:22 docs\ndrwxr-xr-x  5 root root   4096 Sep 10 09:22 examples\ndrwxrwxrwx  2 root root   4096 Sep 10 09:22 licenses\n-rw-r--r--  1 root root    268 Sep 10 09:22 pip-requirements\n-rw-r--r--  1 root root   5461 Sep 10 09:24 pyproject.toml\n-rw-r--r--  1 root root   6814 Sep 10 09:22 setup.cfg\n-rwxr-xr-x  1 root root   1634 Sep 10 09:22 setup.py\n-rw-r--r--  1 root root   5718 Sep 10 09:22 tox.ini\ngrep: testbed: No such file or directory\n",
      "perturbed": "total 672\ndrwxr-xr-x  1 root root   4096 Nov 29 03:28 ..\n-rw-r--r--  1 root root      0 Sep 10 09:22 .astropy-root\ndrwxrwxrwx  2 root root   4096 Sep 10 09:22 .circleci\n-rw-r--r--  1 root root     16 Sep 10 09:22 .gitattributes\ndrwxrwxrwx  8 root root   4096 Sep 10 09:26 .git\ndrwxrwxrwx  4 root root   4096 Sep 10 09:22 .github\n-rw-r--r--  1 root root   1218 Sep 10 09:22 .gitignore\n-rw-r--r--  1 root root  19977 Sep 10 09:22 .mailmap\n-rw-r--r--  1 root root   2056 Sep 10 09:22 .pep8speaks.yml\n-rw-r--r--  1 root root   2799 Sep 10 09:22 .pre-commit-config.yaml\ndrwxrwxrwx  3 root root   4096 Sep 10 09:22 .pyinstaller\n-rw-r--r--  1 root root 507755 Sep 10 09:22 CHANGES.rst\n-rw-r--r--  1 root root     66 Sep 10 09:22 CITATION\n-rw-r--r--  1 root root    139 Sep 10 09:22 CODE_OF_CONDUCT.md\n-rw-r--r--  1 root root   9569 Sep 10 09:22 CONTRIBUTING.md\n-rw-r--r--  1 root root    129 Sep 10 09:22 GOVERNANCE.md\n-rw-r--r--  1 root root   1496 Sep 10 09:22 LICENSE.rst\n-rw-r--r--  1 root root    703 Sep 10 09:22 MANIFEST.in\n-rw-r--r--  1 root root   4558 Sep 10 09:22 README.rst\ndrwxrwxrwx 24 root root   4096 Sep 10 09:26 astropy\ndrwxr-xr-x  2 root root   4096 Sep 10 09:24 astropy.egg-info\ndrwxrwxrwx  5 root root   4096 Sep 10 09:22 cextern\n-rw-r--r--  1 root root   4140 Sep 10 09:22 azure-pipelines.yml\n-rw-r--r--  1 root root     13 Sep 10 09:22 codecov.yml\n-rw-r--r--  1 root root   2568 Sep 10 09:22 conftest.py\ndrwxr-xr-x  5 root root   4096 Sep 10 09:22 examples\n-rw-r--r--  1 root root    268 Sep 10 09:22 pip-requirements\ndrwxrwxrwx  2 root root   4096 Sep 10 09:22 licenses\n-rw-r--r--  1 root root   5461 Sep 10 09:24 pyproject.toml\n-rwxr-xr-x  1 root root   1634 Sep 10 09:22 setup.py\n-rw-r--r--  1 root root   6814 Sep 10 09:22 setup.cfg\n-rw-r--r--  1 root root   5718 Sep 10 09:22 tox.ini\ngrep: testbed: No such file or directory",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba astropy/timeseries/core.py | sed -n '1,240p'",
      "original": "     1\t# Licensed under a 3-clause BSD style license - see LICENSE.rst\n     2\t\n     3\tfrom types import FunctionType\n     4\tfrom contextlib import contextmanager\n     5\tfrom functools import wraps\n     6\t\n     7\tfrom astropy.table import QTable\n     8\t\n     9\t__all__ = ['BaseTimeSeries', 'autocheck_required_columns']\n    10\t\n    11\tCOLUMN_RELATED_METHODS = ['add_column',\n    12\t                          'add_columns',\n    13\t                          'keep_columns',\n    14\t                          'remove_column',\n    15\t                          'remove_columns',\n    16\t                          'rename_column']\n    17\t\n    18\t\n    19\tdef autocheck_required_columns(cls):\n    20\t    \"\"\"\n    21\t    This is a decorator that ensures that the table contains specific\n    22\t    methods indicated by the _required_columns attribute. The aim is to\n    23\t    decorate all methods that might affect the columns in the table and check\n    24\t    for consistency after the methods have been run.\n    25\t    \"\"\"\n    26\t\n    27\t    def decorator_method(method):\n    28\t\n    29\t        @wraps(method)\n    30\t        def wrapper(self, *args, **kwargs):\n    31\t            result = method(self, *args, **kwargs)\n    32\t            self._check_required_columns()\n    33\t            return result\n    34\t\n    35\t        return wrapper\n    36\t\n    37\t    for name in COLUMN_RELATED_METHODS:\n    38\t        if (not hasattr(cls, name) or\n    39\t                not isinstance(getattr(cls, name), FunctionType)):\n    40\t            raise ValueError(f\"{name} is not a valid method\")\n    41\t        setattr(cls, name, decorator_method(getattr(cls, name)))\n    42\t\n    43\t    return cls\n    44\t\n    45\t\n    46\tclass BaseTimeSeries(QTable):\n    47\t\n    48\t    _required_columns = None\n    49\t    _required_columns_enabled = True\n    50\t\n    51\t    # If _required_column_relax is True, we don't require the columns to be\n    52\t    # present but we do require them to be the correct ones IF present. Note\n    53\t    # that this is a temporary state - as soon as the required columns\n    54\t    # are all present, we toggle this to False\n    55\t    _required_columns_relax = False\n    56\t\n    57\t    def _check_required_columns(self):\n    58\t\n    59\t        if not self._required_columns_enabled:\n    60\t            return\n    61\t\n    62\t        if self._required_columns is not None:\n    63\t\n    64\t            if self._required_columns_relax:\n    65\t                required_columns = self._required_columns[:len(self.colnames)]\n    66\t            else:\n    67\t                required_columns = self._required_columns\n    68\t\n    69\t            plural = 's' if len(required_columns) > 1 else ''\n    70\t\n    71\t            if not self._required_columns_relax and len(self.colnames) == 0:\n    72\t\n    73\t                raise ValueError(\"{} object is invalid - expected '{}' \"\n    74\t                                 \"as the first column{} but time series has no columns\"\n    75\t                                 .format(self.__class__.__name__, required_columns[0], plural))\n    76\t\n    77\t            elif self.colnames[:len(required_columns)] != required_columns:\n    78\t\n    79\t                raise ValueError(\"{} object is invalid - expected '{}' \"\n    80\t                                 \"as the first column{} but found '{}'\"\n    81\t                                 .format(self.__class__.__name__, required_columns[0], plural, self.colnames[0]))\n    82\t\n    83\t            if (self._required_columns_relax\n    84\t                    and self._required_columns == self.colnames[:len(self._required_columns)]):\n    85\t                self._required_columns_relax = False\n    86\t\n    87\t    @contextmanager\n    88\t    def _delay_required_column_checks(self):\n    89\t        self._required_columns_enabled = False\n    90\t        yield\n    91\t        self._required_columns_enabled = True\n    92\t        self._check_required_columns()\n",
      "perturbed": "     1\t# Licensed under a 3-clause BSD style license - see LICENSE.rst\n     2\t\n     3\tfrom types import FunctionType\n     4\tfrom contextlib import contextmanager\n     5\tfrom functools import wraps\n     6\t\n     8\t\n     7\tfrom astropy.table import QTable\n     9\t__all__ = ['BaseTimeSeries', 'autocheck_required_columns']\n    10\t\n    11\tCOLUMN_RELATED_METHODS = ['add_column',\n    12\t                          'add_columns',\n    14\t                          'remove_column',\n    15\t                          'remove_columns',\n    16\t                          'rename_column']\n    17\t\n    18\t\n    20\t    \"\"\"\n    19\tdef autocheck_required_columns(cls):\n    21\t    This is a decorator that ensures that the table contains specific\n    23\t    decorate all methods that might affect the columns in the table and check\n    22\t    methods indicated by the _required_columns attribute. The aim is to\n    24\t    for consistency after the methods have been run.\n    27\t    def decorator_method(method):\n    26\t\n    28\t\n    29\t        @wraps(method)\n    30\t        def wrapper(self, *args, **kwargs):\n    31\t            result = method(self, *args, **kwargs)\n    32\t            self._check_required_columns()\n    35\t        return wrapper\n    36\t\n    37\t    for name in COLUMN_RELATED_METHODS:\n    38\t        if (not hasattr(cls, name) or\n    39\t                not isinstance(getattr(cls, name), FunctionType)):\n    40\t            raise ValueError(f\"{name} is not a valid method\")\n    42\t\n    41\t        setattr(cls, name, decorator_method(getattr(cls, name)))\n    43\t    return cls\n    44\t\n    45\t\n    47\t\n    46\tclass BaseTimeSeries(QTable):\n    48\t    _required_columns = None\n    49\t    _required_columns_enabled = True\n    51\t    # If _required_column_relax is True, we don't require the columns to be\n    53\t    # that this is a temporary state - as soon as the required columns\n    54\t    # are all present, we toggle this to False\n    55\t    _required_columns_relax = False\n    57\t    def _check_required_columns(self):\n    56\t\n    60\t            return\n    59\t        if not self._required_columns_enabled:\n    61\t\n    62\t        if self._required_columns is not None:\n    63\t\n    64\t            if self._required_columns_relax:\n    65\t                required_columns = self._required_columns[:len(self.colnames)]\n    66\t            else:\n    68\t\n    69\t            plural = 's' if len(required_columns) > 1 else ''\n    72\t\n    73\t                raise ValueError(\"{} object is invalid - expected '{}' \"\n    74\t                                 \"as the first column{} but time series has no columns\"\n    75\t                                 .format(self.__class__.__name__, required_columns[0], plural))\n    76\t\n    77\t            elif self.colnames[:len(required_columns)] != required_columns:\n    78\t\n    79\t                raise ValueError(\"{} object is invalid - expected '{}' \"\n    80\t                                 \"as the first column{} but found '{}'\"\n    81\t                                 .format(self.__class__.__name__, required_columns[0], plural, self.colnames[0]))\n    82\t\n    84\t                    and self._required_columns == self.colnames[:len(self._required_columns)]):\n    87\t    @contextmanager\n    86\t\n    88\t    def _delay_required_column_checks(self):\n    89\t        self._required_columns_enabled = False\n    90\t        yield\n    91\t        self._required_columns_enabled = True\n    92\t        self._check_required_columns()",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba astropy/timeseries/tests/test_sampled.py | sed -n '1,140p'",
      "original": "     1\t# Licensed under a 3-clause BSD style license - see LICENSE.rst\n     2\t\n     3\tfrom datetime import datetime\n     4\t\n     5\timport pytest\n     6\t\n     7\tfrom numpy.testing import assert_equal, assert_allclose\n     8\t\n     9\tfrom astropy.table import Table, Column\n    10\tfrom astropy.time import Time, TimeDelta\n    11\tfrom astropy import units as u\n    12\tfrom astropy.units import Quantity\n    13\tfrom astropy.utils.data import get_pkg_data_filename\n    14\tfrom astropy.tests.helper import assert_quantity_allclose\n    15\t\n    16\tfrom astropy.timeseries.periodograms import BoxLeastSquares, LombScargle\n    17\tfrom astropy.timeseries.sampled import TimeSeries\n    18\t\n    19\tINPUT_TIME = Time(['2016-03-22T12:30:31',\n    20\t                   '2015-01-21T12:30:32',\n    21\t                   '2016-03-22T12:30:40'])\n    22\tPLAIN_TABLE = Table([[1, 2, 11], [3, 4, 1], [1, 1, 1]], names=['a', 'b', 'c'])\n    23\t\n    24\tCSV_FILE = get_pkg_data_filename('data/sampled.csv')\n    25\t\n    26\t\n    27\tdef test_empty_initialization():\n    28\t    ts = TimeSeries()\n    29\t    ts['time'] = Time([50001, 50002, 50003], format='mjd')\n    30\t\n    31\t\n    32\tdef test_empty_initialization_invalid():\n    33\t    # Make sure things crash when the first column added is not a time column\n    34\t    ts = TimeSeries()\n    35\t    with pytest.raises(ValueError) as exc:\n    36\t        ts['flux'] = [1, 2, 3]\n    37\t    assert exc.value.args[0] == (\"TimeSeries object is invalid - expected \"\n    38\t                                 \"'time' as the first column but found 'flux'\")\n    39\t\n    40\t\n    41\tdef test_initialize_only_time():\n    42\t    ts = TimeSeries(time=INPUT_TIME)\n    43\t    assert ts['time'] is ts.time\n    44\t    # NOTE: the object in the table is a copy\n    45\t    assert_equal(ts.time.isot, INPUT_TIME.isot)\n    46\t\n    47\t\n    48\tdef test_initialization_with_data():\n    49\t    ts = TimeSeries(time=INPUT_TIME, data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    50\t    assert_equal(ts.time.isot, INPUT_TIME.isot)\n    51\t    assert_equal(ts['a'], [10, 2, 3])\n    52\t    assert_equal(ts['b'], [4, 5, 6])\n    53\t\n    54\t\n    55\tdef test_initialize_only_data():\n    56\t    with pytest.raises(TypeError) as exc:\n    57\t        TimeSeries(data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    58\t    assert exc.value.args[0] == \"Either 'time' or 'time_start' should be specified\"\n    59\t\n    60\t\n    61\tdef test_initialization_with_table():\n    62\t    ts = TimeSeries(time=INPUT_TIME, data=PLAIN_TABLE)\n    63\t    assert ts.colnames == ['time', 'a', 'b', 'c']\n    64\t\n    65\t\n    66\tdef test_initialization_with_time_delta():\n    67\t    ts = TimeSeries(time_start=datetime(2018, 7, 1, 10, 10, 10),\n    68\t                    time_delta=TimeDelta(3, format='sec'),\n    69\t                    data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    70\t    assert_equal(ts.time.isot, ['2018-07-01T10:10:10.000',\n    71\t                                '2018-07-01T10:10:13.000',\n    72\t                                '2018-07-01T10:10:16.000'])\n    73\t\n    74\t\n    75\tdef test_initialization_missing_time_delta():\n    76\t    with pytest.raises(TypeError) as exc:\n    77\t        TimeSeries(time_start=datetime(2018, 7, 1, 10, 10, 10),\n    78\t                   data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    79\t    assert exc.value.args[0] == \"'time' is scalar, so 'time_delta' is required\"\n    80\t\n    81\t\n    82\tdef test_initialization_invalid_time_and_time_start():\n    83\t    with pytest.raises(TypeError) as exc:\n    84\t        TimeSeries(time=INPUT_TIME, time_start=datetime(2018, 7, 1, 10, 10, 10),\n    85\t                   data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    86\t    assert exc.value.args[0] == \"Cannot specify both 'time' and 'time_start'\"\n    87\t\n    88\t\n    89\tdef test_initialization_invalid_time_delta():\n    90\t    with pytest.raises(TypeError) as exc:\n    91\t        TimeSeries(time_start=datetime(2018, 7, 1, 10, 10, 10),\n    92\t                   time_delta=[1, 4, 3],\n    93\t                   data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    94\t    assert exc.value.args[0] == \"'time_delta' should be a Quantity or a TimeDelta\"\n    95\t\n    96\t\n    97\tdef test_initialization_with_time_in_data():\n    98\t\n    99\t    data = PLAIN_TABLE.copy()\n   100\t    data['time'] = INPUT_TIME\n   101\t\n   102\t    ts1 = TimeSeries(data=data)\n   103\t\n   104\t    assert set(ts1.colnames) == set(['time', 'a', 'b', 'c'])\n   105\t    assert all(ts1.time == INPUT_TIME)\n   106\t\n   107\t    ts2 = TimeSeries(data=[[10, 2, 3], INPUT_TIME], names=['a', 'time'])\n   108\t    assert set(ts2.colnames) == set(['time', 'a'])\n   109\t    assert all(ts2.time == INPUT_TIME)\n   110\t\n   111\t    with pytest.raises(TypeError) as exc:\n   112\t        # Don't allow ambiguous cases of passing multiple 'time' columns\n   113\t        TimeSeries(data=data, time=INPUT_TIME)\n   114\t    assert exc.value.args[0] == \"'time' has been given both in the table and as a keyword argument\"\n   115\t\n   116\t    with pytest.raises(TypeError) as exc:\n   117\t        # 'time' is a protected name, don't allow ambiguous cases\n   118\t        TimeSeries(time=INPUT_TIME, data=[[10, 2, 3], INPUT_TIME], names=['a', 'time'])\n   119\t    assert exc.value.args[0] == \"'time' has been given both in the table and as a keyword argument\"\n   120\t\n   121\t\n   122\tdef test_initialization_n_samples():\n   123\t\n   124\t    # Make sure things crash with incorrect n_samples\n   125\t\n   126\t    with pytest.raises(TypeError) as exc:\n   127\t        TimeSeries(time=INPUT_TIME, data=PLAIN_TABLE, n_samples=1000)\n   128\t    assert exc.value.args[0] == (\"'n_samples' has been given both and it is not the \"\n   129\t                                 \"same length as the input data.\")\n   130\t\n   131\t\n   132\tdef test_initialization_length_mismatch():\n   133\t    with pytest.raises(ValueError) as exc:\n   134\t        TimeSeries(time=INPUT_TIME, data=[[10, 2], [4, 5]], names=['a', 'b'])\n   135\t    assert exc.value.args[0] == \"Length of 'time' (3) should match data length (2)\"\n   136\t\n   137\t\n   138\tdef test_initialization_invalid_both_time_and_time_delta():\n   139\t    with pytest.raises(TypeError) as exc:\n   140\t        TimeSeries(time=INPUT_TIME, time_delta=TimeDelta(3, format='sec'))\n",
      "perturbed": "     1\t# Licensed under a 3-clause BSD style license - see LICENSE.rst\n     2\t\n     4\t\n     6\t\n     5\timport pytest\n     7\tfrom numpy.testing import assert_equal, assert_allclose\n     8\t\n     9\tfrom astropy.table import Table, Column\n    10\tfrom astropy.time import Time, TimeDelta\n    11\tfrom astropy import units as u\n    13\tfrom astropy.utils.data import get_pkg_data_filename\n    12\tfrom astropy.units import Quantity\n    14\tfrom astropy.tests.helper import assert_quantity_allclose\n    15\t\n    17\tfrom astropy.timeseries.sampled import TimeSeries\n    16\tfrom astropy.timeseries.periodograms import BoxLeastSquares, LombScargle\n    18\t\n    19\tINPUT_TIME = Time(['2016-03-22T12:30:31',\n    22\tPLAIN_TABLE = Table([[1, 2, 11], [3, 4, 1], [1, 1, 1]], names=['a', 'b', 'c'])\n    23\t\n    24\tCSV_FILE = get_pkg_data_filename('data/sampled.csv')\n    25\t\n    26\t\n    28\t    ts = TimeSeries()\n    29\t    ts['time'] = Time([50001, 50002, 50003], format='mjd')\n    30\t\n    31\t\n    32\tdef test_empty_initialization_invalid():\n    33\t    # Make sure things crash when the first column added is not a time column\n    36\t        ts['flux'] = [1, 2, 3]\n    38\t                                 \"'time' as the first column but found 'flux'\")\n    37\t    assert exc.value.args[0] == (\"TimeSeries object is invalid - expected \"\n    40\t\n    41\tdef test_initialize_only_time():\n    43\t    assert ts['time'] is ts.time\n    42\t    ts = TimeSeries(time=INPUT_TIME)\n    44\t    # NOTE: the object in the table is a copy\n    45\t    assert_equal(ts.time.isot, INPUT_TIME.isot)\n    46\t\n    48\tdef test_initialization_with_data():\n    47\t\n    49\t    ts = TimeSeries(time=INPUT_TIME, data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    50\t    assert_equal(ts.time.isot, INPUT_TIME.isot)\n    51\t    assert_equal(ts['a'], [10, 2, 3])\n    52\t    assert_equal(ts['b'], [4, 5, 6])\n    53\t\n    55\tdef test_initialize_only_data():\n    56\t    with pytest.raises(TypeError) as exc:\n    58\t    assert exc.value.args[0] == \"Either 'time' or 'time_start' should be specified\"\n    60\t\n    61\tdef test_initialization_with_table():\n    62\t    ts = TimeSeries(time=INPUT_TIME, data=PLAIN_TABLE)\n    64\t\n    63\t    assert ts.colnames == ['time', 'a', 'b', 'c']\n    65\t\n    68\t                    time_delta=TimeDelta(3, format='sec'),\n    67\t    ts = TimeSeries(time_start=datetime(2018, 7, 1, 10, 10, 10),\n    69\t                    data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    71\t                                '2018-07-01T10:10:13.000',\n    70\t    assert_equal(ts.time.isot, ['2018-07-01T10:10:10.000',\n    72\t                                '2018-07-01T10:10:16.000'])\n    73\t\n    74\t\n    76\t    with pytest.raises(TypeError) as exc:\n    75\tdef test_initialization_missing_time_delta():\n    77\t        TimeSeries(time_start=datetime(2018, 7, 1, 10, 10, 10),\n    78\t                   data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    80\t\n    82\tdef test_initialization_invalid_time_and_time_start():\n    83\t    with pytest.raises(TypeError) as exc:\n    85\t                   data=[[10, 2, 3], [4, 5, 6]], names=['a', 'b'])\n    87\t\n    88\t\n    89\tdef test_initialization_invalid_time_delta():\n    90\t    with pytest.raises(TypeError) as exc:\n    91\t        TimeSeries(time_start=datetime(2018, 7, 1, 10, 10, 10),\n    92\t                   time_delta=[1, 4, 3],\n    94\t    assert exc.value.args[0] == \"'time_delta' should be a Quantity or a TimeDelta\"\n    95\t\n    96\t\n   100\t    data['time'] = INPUT_TIME\n    99\t    data = PLAIN_TABLE.copy()\n   101\t\n   102\t    ts1 = TimeSeries(data=data)\n   103\t\n   105\t    assert all(ts1.time == INPUT_TIME)\n   104\t    assert set(ts1.colnames) == set(['time', 'a', 'b', 'c'])\n   107\t    ts2 = TimeSeries(data=[[10, 2, 3], INPUT_TIME], names=['a', 'time'])\n   106\t\n   108\t    assert set(ts2.colnames) == set(['time', 'a'])\n   110\t\n   109\t    assert all(ts2.time == INPUT_TIME)\n   112\t        # Don't allow ambiguous cases of passing multiple 'time' columns\n   111\t    with pytest.raises(TypeError) as exc:\n   113\t        TimeSeries(data=data, time=INPUT_TIME)\n   114\t    assert exc.value.args[0] == \"'time' has been given both in the table and as a keyword argument\"\n   115\t\n   116\t    with pytest.raises(TypeError) as exc:\n   117\t        # 'time' is a protected name, don't allow ambiguous cases\n   118\t        TimeSeries(time=INPUT_TIME, data=[[10, 2, 3], INPUT_TIME], names=['a', 'time'])\n   120\t\n   119\t    assert exc.value.args[0] == \"'time' has been given both in the table and as a keyword argument\"\n   121\t\n   122\tdef test_initialization_n_samples():\n   123\t\n   124\t    # Make sure things crash with incorrect n_samples\n   125\t\n   126\t    with pytest.raises(TypeError) as exc:\n   127\t        TimeSeries(time=INPUT_TIME, data=PLAIN_TABLE, n_samples=1000)\n   131\t\n   130\t\n   134\t        TimeSeries(time=INPUT_TIME, data=[[10, 2], [4, 5]], names=['a', 'b'])\n   136\t\n   135\t    assert exc.value.args[0] == \"Length of 'time' (3) should match data length (2)\"\n   138\tdef test_initialization_invalid_both_time_and_time_delta():\n   137\t\n   139\t    with pytest.raises(TypeError) as exc:\n   140\t        TimeSeries(time=INPUT_TIME, time_delta=TimeDelta(3, format='sec'))",
      "applied_operators": [
        "text_perturbation"
      ]
    }
  ]
}