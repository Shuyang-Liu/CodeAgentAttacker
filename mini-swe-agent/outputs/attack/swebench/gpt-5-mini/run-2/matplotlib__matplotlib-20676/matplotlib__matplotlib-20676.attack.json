{
  "info": {
    "total_observations": 11,
    "python_observations": 1,
    "text_observations": 10,
    "ast_operators_applied": 0,
    "text_perturbation_applied": 6,
    "skipped": 5
  },
  "perturbations": [
    {
      "action": "ls -la",
      "original": "total 212\ndrwxrwxrwx  1 root root  4096 Sep 10 14:02 .\ndrwxr-xr-x  1 root root  4096 Nov 30 01:35 ..\n-rw-r--r--  1 root root  3839 Sep 10 13:47 .appveyor.yml\ndrwxrwxrwx  2 root root  4096 Sep 10 13:47 .circleci\n-rw-r--r--  1 root root   227 Sep 10 13:47 .coveragerc\ndrwxr-xr-x  3 root root  4096 Sep 10 14:02 .eggs\n-rw-r--r--  1 root root  4973 Sep 10 13:47 .flake8\ndrwxrwxrwx  8 root root  4096 Sep 10 14:03 .git\n-rw-r--r--  1 root root    23 Sep 10 13:47 .git_archival.txt\n-rw-r--r--  1 root root    98 Sep 10 13:47 .gitattributes\ndrwxrwxrwx  4 root root  4096 Sep 10 13:47 .github\n-rw-r--r--  1 root root  1757 Sep 10 13:47 .gitignore\n-rw-r--r--  1 root root   639 Sep 10 13:47 .lgtm.yml\n-rw-r--r--  1 root root  8849 Sep 10 13:47 .mailmap\n-rw-r--r--  1 root root    44 Sep 10 13:47 .meeseeksdev.yml\n-rw-r--r--  1 root root  5610 Sep 10 13:47 CODE_OF_CONDUCT.md\n-rw-r--r--  1 root root  2288 Sep 10 13:47 INSTALL.rst\ndrwxrwxrwx  2 root root  4096 Sep 10 14:02 LICENSE\n-rw-r--r--  1 root root  4902 Sep 10 13:47 README.rst\n-rw-r--r--  1 root root  1070 Sep 10 13:47 SECURITY.md\ndrwxr-xr-x  2 root root  4096 Sep 10 14:02 __pycache__\n-rw-r--r--  1 root root  3355 Sep 10 13:47 azure-pipelines.yml\ndrwxr-xr-x  6 root root  4096 Sep 10 14:02 build\ndrwxrwxrwx  2 root root  4096 Sep 10 13:47 ci\ndrwxrwxrwx 11 root root  4096 Sep 10 13:47 doc\ndrwxr-xr-x 27 root root  4096 Sep 10 13:47 examples\ndrwxrwxrwx  4 root root  4096 Sep 10 13:47 extern\ndrwxrwxrwx  5 root root  4096 Sep 10 14:02 lib\ndrwxr-xr-x  6 root root  4096 Sep 10 13:47 plot_types\n-rw-r--r--  1 root root   155 Sep 10 13:47 pytest.ini\ndrwxrwxrwx  5 root root  4096 Sep 10 13:47 requirements\n-rw-r--r--  1 root root  1488 Sep 10 13:47 setup.cfg.template\n-rw-r--r--  1 root root 13349 Sep 10 13:47 setup.py\n-rw-r--r--  1 root root 24518 Sep 10 13:47 setupext.py\ndrwxrwxrwx  4 root root  4096 Sep 10 13:47 src\n-rwxr-xr-x  1 root root  1069 Sep 10 13:47 tests.py\ndrwxr-xr-x  2 root root  4096 Sep 10 14:02 tmp\ndrwxrwxrwx  2 root root  4096 Sep 10 13:47 tools\n-rw-r--r--  1 root root   576 Sep 10 13:47 tox.ini\ndrwxr-xr-x  9 root root  4096 Sep 10 13:47 tutorials\n",
      "perturbed": "drwxr-xr-x  1 root root  4096 Nov 30 01:35 ..\ndrwxrwxrwx  2 root root  4096 Sep ...\n-rw-r--r--  1 root root  3839 Sep 10 13:47 .appveyor.yml\ndrwxr-xr-x  3 root root  4096 Sep 10 14:02 .eggs\n-rw-r--r--  1 root root   227 Sep 10 13:47 .coveragerc\n-rw-r--r--  1 root root  4973 Sep 10 13:47 .flake8\ndrwxrwxrwx  8 root root  4096 Sep 10 14:03 .git\n-rw-r--r--  1 root root    98 Sep 10 13:47 .gitattributes\ndrwxrwxrwx  4 root root  4096 Sep 10 13:47 .github\n-rw-r--r--  1 root root  2288 Sep 10 13:47 INSTALL.rst\n-rw-r--r--  1 root root  1757 Sep 10 13:47 .gitignore\ndrwxrwxrwx  2 root root  4096 Sep 10 14:02 LICENSE\n-rw-r--r--  1 root root  1070 Sep 10 13:47 SECURITY.md\n-rw-r--r--  1 root root  4902 Sep 10 13:47 README.rst\ndrwxr-xr-x  2 root root  4096 Sep 10 14:02 _...\n-rw-r--r--  1 root root  3355 Sep 10 13:47 azure-pipelines.yml\ndrwxr-xr-x  6 root root  4096 Sep 10 14:02 build\ndrwxrwxrwx  2 root root  4096 Sep 10 13:47 ci\ndrwxrwxrwx 11 root root  4096 Sep 10 13:47 doc\ndrwxrwxrwx  4 root root  4096 Sep 10 13:47 extern\ndrwxrwxrwx  5 root root ...\ndrwxr-xr-x  6 root root  4096 Sep 10 13:47 plot_types\n-rw-r--r--  1 root root   155 Sep 10 13:47 pytest.ini\ndrwxrwxrwx  5 root root  4096 Sep 10 13:47 requirements\n-rw-r--r--  1 root root  1488 Sep 10 13:47 setup.cfg.template\n-rw-r--r--  1 root root 13349 Sep 10 13:47 setup.py\ndrwxrwxrwx  2 root root  4096 Sep 10 13...\ndrwxrwxrwx  4 root root  4096 Sep 10 13:47 src\ndrwxr-xr-x  9 root root  4096 Sep 10 13:47 tutorials",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "grep -R --line-number --no-color \"SpanSelector\" src || true",
      "original": "grep: unrecognized option '--no-color'\nUsage: grep [OPTION]... PATTERNS [FILE]...\nTry 'grep --help' for more information.\n",
      "perturbed": "Usage: grep [OPTION]... PATTERNS [FILE]...\nTry 'grep --help' for more information.",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba lib/matplotlib/widgets.py | sed -n '1960,2100p'",
      "original": "  1960\t                for artist in self.artists:\n  1961\t                    artist.set_visible(False)\n  1962\t                self.update()\n  1963\t                return\n  1964\t            for (state, modifier) in self.state_modifier_keys.items():\n  1965\t                if modifier in key:\n  1966\t                    self._state.add(state)\n  1967\t            self._on_key_press(event)\n  1968\t\n  1969\t    def _on_key_press(self, event):\n  1970\t        \"\"\"Key press event handler - for widget-specific key press actions.\"\"\"\n  1971\t\n  1972\t    def on_key_release(self, event):\n  1973\t        \"\"\"Key release event handler and validator.\"\"\"\n  1974\t        if self.active:\n  1975\t            key = event.key or ''\n  1976\t            for (state, modifier) in self.state_modifier_keys.items():\n  1977\t                if modifier in key:\n  1978\t                    self._state.discard(state)\n  1979\t            self._on_key_release(event)\n  1980\t\n  1981\t    def _on_key_release(self, event):\n  1982\t        \"\"\"Key release event handler.\"\"\"\n  1983\t\n  1984\t    def set_visible(self, visible):\n  1985\t        \"\"\"Set the visibility of our artists.\"\"\"\n  1986\t        self.visible = visible\n  1987\t        for artist in self.artists:\n  1988\t            artist.set_visible(visible)\n  1989\t\n  1990\t\n  1991\tclass SpanSelector(_SelectorWidget):\n  1992\t    \"\"\"\n  1993\t    Visually select a min/max range on a single axis and call a function with\n  1994\t    those values.\n  1995\t\n  1996\t    To guarantee that the selector remains responsive, keep a reference to it.\n  1997\t\n  1998\t    In order to turn off the SpanSelector, set ``span_selector.active`` to\n  1999\t    False.  To turn it back on, set it to True.\n  2000\t\n  2001\t    Parameters\n  2002\t    ----------\n  2003\t    ax : `matplotlib.axes.Axes`\n  2004\t\n  2005\t    onselect : callable\n  2006\t        A callback function to be called when the selection is completed.\n  2007\t        It must have the signature::\n  2008\t\n  2009\t            def on_select(min: float, max: float) -> Any\n  2010\t\n  2011\t    direction : {\"horizontal\", \"vertical\"}\n  2012\t        The direction along which to draw the span selector.\n  2013\t\n  2014\t    minspan : float, default: 0\n  2015\t        If selection is less than or equal to *minspan*, do not call\n  2016\t        *onselect*.\n  2017\t\n  2018\t    useblit : bool, default: False\n  2019\t        If True, use the backend-dependent blitting features for faster\n  2020\t        canvas updates.\n  2021\t\n  2022\t    rectprops : dict, default: None\n  2023\t        Dictionary of `matplotlib.patches.Patch` properties.\n  2024\t\n  2025\t    onmove_callback : func(min, max), min/max are floats, default: None\n  2026\t        Called on mouse move while the span is being selected.\n  2027\t\n  2028\t    span_stays : bool, default: False\n  2029\t        If True, the span stays visible after the mouse is released.\n  2030\t        Deprecated, use interactive instead.\n  2031\t\n  2032\t    interactive : bool, default: False\n  2033\t        Whether to draw a set of handles that allow interaction with the\n  2034\t        widget after it is drawn.\n  2035\t\n  2036\t    button : `.MouseButton` or list of `.MouseButton`, default: all buttons\n  2037\t        The mouse buttons which activate the span selector.\n  2038\t\n  2039\t    handle_props : dict, default: None\n  2040\t        Properties of the handle lines at the edges of the span. Only used\n  2041\t        when *interactive* is True. See `~matplotlib.lines.Line2D` for valid\n  2042\t        properties.\n  2043\t\n  2044\t    handle_grab_distance : float, default: 10\n  2045\t        Distance in pixels within which the interactive tool handles can be\n  2046\t        activated.\n  2047\t\n  2048\t    drag_from_anywhere : bool, default: False\n  2049\t        If `True`, the widget can be moved by clicking anywhere within\n  2050\t        its bounds.\n  2051\t\n  2052\t    Examples\n  2053\t    --------\n  2054\t    >>> import matplotlib.pyplot as plt\n  2055\t    >>> import matplotlib.widgets as mwidgets\n  2056\t    >>> fig, ax = plt.subplots()\n  2057\t    >>> ax.plot([1, 2, 3], [10, 50, 100])\n  2058\t    >>> def onselect(vmin, vmax):\n  2059\t    ...     print(vmin, vmax)\n  2060\t    >>> rectprops = dict(facecolor='blue', alpha=0.5)\n  2061\t    >>> span = mwidgets.SpanSelector(ax, onselect, 'horizontal',\n  2062\t    ...                              rectprops=rectprops)\n  2063\t    >>> fig.show()\n  2064\t\n  2065\t    See also: :doc:`/gallery/widgets/span_selector`\n  2066\t    \"\"\"\n  2067\t\n  2068\t    @_api.rename_parameter(\"3.5\", \"span_stays\", \"interactive\")\n  2069\t    def __init__(self, ax, onselect, direction, minspan=0, useblit=False,\n  2070\t                 rectprops=None, onmove_callback=None, interactive=False,\n  2071\t                 button=None, handle_props=None, handle_grab_distance=10,\n  2072\t                 drag_from_anywhere=False):\n  2073\t\n  2074\t        super().__init__(ax, onselect, useblit=useblit, button=button)\n  2075\t\n  2076\t        if rectprops is None:\n  2077\t            rectprops = dict(facecolor='red', alpha=0.5)\n  2078\t\n  2079\t        rectprops['animated'] = self.useblit\n  2080\t\n  2081\t        self.direction = direction\n  2082\t\n  2083\t        self._rect = None\n  2084\t        self.visible = True\n  2085\t        self._extents_on_press = None\n  2086\t\n  2087\t        # self._pressv is deprecated and we don't use it internally anymore\n  2088\t        # but we maintain it until it is removed\n  2089\t        self._pressv = None\n  2090\t\n  2091\t        self._rectprops = rectprops\n  2092\t        self.onmove_callback = onmove_callback\n  2093\t        self.minspan = minspan\n  2094\t\n  2095\t        self.handle_grab_distance = handle_grab_distance\n  2096\t        self._interactive = interactive\n  2097\t        self.drag_from_anywhere = drag_from_anywhere\n  2098\t\n  2099\t        # Reset canvas so that `new_axes` connects events.\n  2100\t        self.canvas = None\n",
      "perturbed": "1961\t                    artist.set_visible(False)\n1960\t                for artist in self.art...\n1962\t                self.update()\n1965\t                if modifier in key:\n1966\t                    self._state.add(state)\n1967\t            self._on_key_press(event)\n1969\t    def _on_key_press(self, event):\n1968\n1970\t        \"\"\"Key press event handler - for widget-specific key press actions.\"\"\"\n1971\n1972\t    def on_key_release(self, event):\n1976\t            for (state, modifier) in self.state_modifier_keys.items():\n1977\t                if modifier in key:\n1978\t                    self._state.discard(state)\n1979\t            self._on_key_release(event)\n1980\n1981\t    def _on_key_release(self, event):\n1983\n1986\t        self.visible = visible\n1987\t        for artist in self.artists:\n1989\nerror: minor issue encountered\n1992\t    \"\"\"\n1994\t    those values.\n1993\t    Visually select a min/max range on a single axis and call a function with\n1995\n1996\t    To guarantee that the selector remains responsive, keep a reference to it.\n1997\n1998\t    In order to turn off the SpanSelector, set ``span_selector.active`` to\n1999\t    False.  To turn it back on, set it to True.\n2000\n2003\t    ax : `matplotlib.axes.Axes`\n2002\t    ----------\n2005\t    onselect : callable\n2006\t        A callback function to be called when the selection is completed.\n2007\t        It must have the signature::\n2008\n2009\t            def on_select(min: float, max: float) -> Any\n2011\t    direction : {\"horizontal\", \"vertical\"}\n2012\t        The direction along which to draw the span selector.\n2013\n2015\t        If selection is less than or equal to *minspan*, do not call\n2014\t    minspan : float, default: 0\n2018\t    useblit : bool, default: False\n2019\t        If True, use the backend-dependent blitting features for faster\n2020\t        canvas updates.\n2022\t    rectprops : dict, default: None\n2021\n2023\t        Dictionary of `matplotlib.patches.Patch` properties.\n2024\n2026\t        Called on mouse move while the span is being selected.\n2028\t    span_stays : bool, default: False\n2030\t        Deprecated, use interactive instead.\n2032\t    interactive : bool, default: False\n2031\nall tests passed successfully\n2034\t        widget after it is drawn.\n2035\n2036\t    button : `.MouseButton` or list of `.MouseButton`, default: all buttons\ninfo: continuing execution\n2037\t        The mouse buttons which activate the span selector.\n2042\t        properties.\n2038\n2043\n2044\t    handle_grab_distance : float, default: 10\n2045\t        Distance in pixels within which the interactive tool handles can be\n2046\t        activated.\n2047\n2050\t        its bounds.\n2051\n2052\t    Examples\n2054\t    >>> import matplotlib.pyplot as plt\n2055\t    >>> import matplotlib.widgets as mwidgets\n2057\t    >>> ax.plot([1, 2, 3], [10, 50, 100])\n2058\t    >>> def onselect(vmin, vmax):\n2059\t    ...     print(vmin, vmax)\n2060\t    >>> rectprops = dict(facecolor='blue',...\n2061\t    >>> span = mwidgets.SpanSelector(ax, onselect, 'horizontal',\n2062\t    ...                              rectprops=rectprops)\n2063\t    >>> fig.show()\n2067\n2066\t    \"\"\"\n2068\t    @_api.rename_parameter(\"3.5\", \"span_stays\", \"interactive\")\n2069\t    def __init__(self, ax, onselect, direction, minspan=0, useblit=False,\n2070\t                 rectprops=None, onmove_callback=None, interactive=False,\n2071\t                 button=None, handle_props=None, handle_grab_distance=10,\n2072\t                 drag_from_anywhere=False):\n2074\t        super().__init__(ax, onselect, useblit=useblit, button=button)\n2075\n2077\t            rectprops = dict(facecolor='red', alpha=0.5)\n2078\n2080\n2081\t        self.direction = direction\n2085\t        self._extents_on_press = None\n2082\n2087\t        # self._pressv is deprecated and we don't use it internally anymore\n2090\n2091\t        self._rectprops = rectprops\n2093\t        self.minspan = minspan\n2094\n2095\t        self.handle_grab_distance = handle_grab_distance\n2096\t        self._interactive = interactive\n2098\n2097\t        self.drag_from_anywhere = drag_from_anywhere\n2100\t        self.canvas = None",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba lib/matplotlib/widgets.py | sed -n '1840,1990p'",
      "original": "  1840\t            return True\n  1841\t        # If canvas was locked\n  1842\t        if not self.canvas.widgetlock.available(self):\n  1843\t            return True\n  1844\t        if not hasattr(event, 'button'):\n  1845\t            event.button = None\n  1846\t        # Only do rectangle selection if event was triggered\n  1847\t        # with a desired button\n  1848\t        if (self.validButtons is not None\n  1849\t                and event.button not in self.validButtons):\n  1850\t            return True\n  1851\t        # If no button was pressed yet ignore the event if it was out\n  1852\t        # of the axes\n  1853\t        if self._eventpress is None:\n  1854\t            return event.inaxes != self.ax\n  1855\t        # If a button was pressed, check if the release-button is the same.\n  1856\t        if event.button == self._eventpress.button:\n  1857\t            return False\n  1858\t        # If a button was pressed, check if the release-button is the same.\n  1859\t        return (event.inaxes != self.ax or\n  1860\t                event.button != self._eventpress.button)\n  1861\t\n  1862\t    def update(self):\n  1863\t        \"\"\"Draw using blit() or draw_idle(), depending on ``self.useblit``.\"\"\"\n  1864\t        if not self.ax.get_visible() or self.ax.figure._cachedRenderer is None:\n  1865\t            return False\n  1866\t        if self.useblit:\n  1867\t            if self.background is not None:\n  1868\t                self.canvas.restore_region(self.background)\n  1869\t            else:\n  1870\t                self.update_background(None)\n  1871\t            for artist in self.artists:\n  1872\t                self.ax.draw_artist(artist)\n  1873\t            self.canvas.blit(self.ax.bbox)\n  1874\t        else:\n  1875\t            self.canvas.draw_idle()\n  1876\t        return False\n  1877\t\n  1878\t    def _get_data(self, event):\n  1879\t        \"\"\"Get the xdata and ydata for event, with limits.\"\"\"\n  1880\t        if event.xdata is None:\n  1881\t            return None, None\n  1882\t        xdata = np.clip(event.xdata, *self.ax.get_xbound())\n  1883\t        ydata = np.clip(event.ydata, *self.ax.get_ybound())\n  1884\t        return xdata, ydata\n  1885\t\n  1886\t    def _clean_event(self, event):\n  1887\t        \"\"\"\n  1888\t        Preprocess an event:\n  1889\t\n  1890\t        - Replace *event* by the previous event if *event* has no ``xdata``.\n  1891\t        - Clip ``xdata`` and ``ydata`` to the axes limits.\n  1892\t        - Update the previous event.\n  1893\t        \"\"\"\n  1894\t        if event.xdata is None:\n  1895\t            event = self._prev_event\n  1896\t        else:\n  1897\t            event = copy.copy(event)\n  1898\t        event.xdata, event.ydata = self._get_data(event)\n  1899\t        self._prev_event = event\n  1900\t        return event\n  1901\t\n  1902\t    def press(self, event):\n  1903\t        \"\"\"Button press handler and validator.\"\"\"\n  1904\t        if not self.ignore(event):\n  1905\t            event = self._clean_event(event)\n  1906\t            self._eventpress = event\n  1907\t            self._prev_event = event\n  1908\t            key = event.key or ''\n  1909\t            key = key.replace('ctrl', 'control')\n  1910\t            # move state is locked in on a button press\n  1911\t            if key == self.state_modifier_keys['move']:\n  1912\t                self._state.add('move')\n  1913\t            self._press(event)\n  1914\t            return True\n  1915\t        return False\n  1916\t\n  1917\t    def _press(self, event):\n  1918\t        \"\"\"Button press event handler.\"\"\"\n  1919\t\n  1920\t    def release(self, event):\n  1921\t        \"\"\"Button release event handler and validator.\"\"\"\n  1922\t        if not self.ignore(event) and self._eventpress:\n  1923\t            event = self._clean_event(event)\n  1924\t            self._eventrelease = event\n  1925\t            self._release(event)\n  1926\t            self._eventpress = None\n  1927\t            self._eventrelease = None\n  1928\t            self._state.discard('move')\n  1929\t            return True\n  1930\t        return False\n  1931\t\n  1932\t    def _release(self, event):\n  1933\t        \"\"\"Button release event handler.\"\"\"\n  1934\t\n  1935\t    def onmove(self, event):\n  1936\t        \"\"\"Cursor move event handler and validator.\"\"\"\n  1937\t        if not self.ignore(event) and self._eventpress:\n  1938\t            event = self._clean_event(event)\n  1939\t            self._onmove(event)\n  1940\t            return True\n  1941\t        return False\n  1942\t\n  1943\t    def _onmove(self, event):\n  1944\t        \"\"\"Cursor move event handler.\"\"\"\n  1945\t\n  1946\t    def on_scroll(self, event):\n  1947\t        \"\"\"Mouse scroll event handler and validator.\"\"\"\n  1948\t        if not self.ignore(event):\n  1949\t            self._on_scroll(event)\n  1950\t\n  1951\t    def _on_scroll(self, event):\n  1952\t        \"\"\"Mouse scroll event handler.\"\"\"\n  1953\t\n  1954\t    def on_key_press(self, event):\n  1955\t        \"\"\"Key press event handler and validator for all selection widgets.\"\"\"\n  1956\t        if self.active:\n  1957\t            key = event.key or ''\n  1958\t            key = key.replace('ctrl', 'control')\n  1959\t            if key == self.state_modifier_keys['clear']:\n  1960\t                for artist in self.artists:\n  1961\t                    artist.set_visible(False)\n  1962\t                self.update()\n  1963\t                return\n  1964\t            for (state, modifier) in self.state_modifier_keys.items():\n  1965\t                if modifier in key:\n  1966\t                    self._state.add(state)\n  1967\t            self._on_key_press(event)\n  1968\t\n  1969\t    def _on_key_press(self, event):\n  1970\t        \"\"\"Key press event handler - for widget-specific key press actions.\"\"\"\n  1971\t\n  1972\t    def on_key_release(self, event):\n  1973\t        \"\"\"Key release event handler and validator.\"\"\"\n  1974\t        if self.active:\n  1975\t            key = event.key or ''\n  1976\t            for (state, modifier) in self.state_modifier_keys.items():\n  1977\t                if modifier in key:\n  1978\t                    self._state.discard(state)\n  1979\t            self._on_key_release(event)\n  1980\t\n  1981\t    def _on_key_release(self, event):\n  1982\t        \"\"\"Key release event handler.\"\"\"\n  1983\t\n  1984\t    def set_visible(self, visible):\n  1985\t        \"\"\"Set the visibility of our artists.\"\"\"\n  1986\t        self.visible = visible\n  1987\t        for artist in self.artists:\n  1988\t            artist.set_visible(visible)\n  1989\t\n  1990\t\n",
      "perturbed": "1840\t            return True\n1841\t        # If canvas was locked\n1842\t        if not self.canvas.widgetlock.available(self):\n1845\t            event.button = None\n1844\t        if not hasattr(event, 'button'):\n1848\t        if (self.validButtons is not None\n1846\t        # Only do rectangle selection if event was triggered\n1849\t                and event.button not in self.validButtons):\n1851\t        # If no button was pressed yet ignore the event if it was out\n1850\t            return True\n1853\t        if self._eventp...\n1854\t            return event.inaxes != self.ax\n1856\t        if event.button == self._eventpress.button:\n1857\t            return False\n1858\t        # If a button was pressed, check if the release-button is the same.\n1860\t                event.button != self._eventpress.button)\n1859\t        return (event.inaxes != self.ax or\n1865\t            return False\n1864\t        if not self.ax.get_visible() or self.ax....\n1866\t        if self.useblit:\n1867\t            if self.background is not None:\n1868\t                self.canvas.restore_region(self.background)\n1869\t            else:\n1870\t                self.update_background(None)\n1872\t                self.ax.draw_artist(artist)\n1871\t            for artist ...\n1874\t        else:\n1873\t            self.canvas.blit(self.ax.bbox)\n1876\t        return False\n1875\t            self.canvas.draw_idle()\ndebug: retrying operation\n1877\n1878\t    def _get_data(self, event):\n1879\t        \"\"\"Get the xdata and ydata for event, with limits.\"\"\"\n1883\t        ydata = np.clip(event.ydata, *self.ax.get_ybound())\n1881\t            return None, None\n1885\n1886\t    def _clean_event(self, event):\n1888\t        Preprocess an event:\n1889\n1890\t        - Replace *event* by the previous event if *event* has no ``xdata``.\n1891\t        - Clip ``xdata`` and ``ydata`` to the axes limits.\n1892\t        - Update the previous event.\n1895\t            event = self._prev_event\n1898\t        event.xdata, event.ydata = self._get_data(event)\n1897\t            event = copy.copy(event)\n1900\t        return event\n1899\t        self._prev_event = event\n1901\n1902\t    def press(self, event):\n1903\t        \"\"\"Button press handler and validator.\"\"\"\n1904\t        if not self.ignore(event):\n1906\t            self._eventpress = event\n1907\t            self._prev_event = event\n1908\t            key = event.key or ''\n1910\t            # move state is locked in on a button press\n1911\t            if key == self.state_modifier_keys['move']:\n1913\t            self._press(event)\n1912\t                self._state.add('move')\n1914\t            return True\n1915\t        return False\n1917\t    def _press(self, event):\n1916\n1918\t        \"\"\"Button press event handler.\"\"\"\n1919\n1920\t    def release(self, event):\n1922\t        if not self.ignore(event) and self._eventpress:\n# additional context omitted\ndebug: retrying operation\n1923\t            event = self._clean_event(event)\n1924\t            self._eventrelease = event\n1925\t            self._release(event)\n1926\t            self._eventpress = None\n1927\t            self._eventrelease = None\n1928\t            self._state.discard('move')\n1929\t            return True\n1930\t        return False\n1932\t    def _release(self, event):\n1934\n1933\t        \"\"\"Button release event handler.\"\"\"\n1935\t    def onmove(self, event):\n1937\t        if not self.igno...\n1940\t            return True\n1941\t        return False\n1942\n1945\n1946\t    def on_scroll(self, event):\n1947\t        \"\"\"Mouse scroll event handler and validator.\"\"\"\n1949\t            self._on_scroll(event)\n1948\t        if not self.ignore(event):\n1950\n1952\t        \"\"\"Mouse scroll event handler.\"\"\"\n1953\n1957\t            key = event.key or ''\n1959\t            if key == self.state_modifier_keys['clear']:\n1958\t            key = key.replace('ctrl', 'control')\n1960\t                for artist in self.artists:\n1963\t                return\n1961\t             ...\n1964\t            for (state, modifier) in self.state_modifier_keys.items():\n1967\t            self._on_key_press(event)\n1970\t        \"\"\"Key press event handler - for widget-specific key press actions.\"\"\"\n1968\n1971\n1972\t    def on_key_release(self, event):\n1974\t        if self.active:\n1978\t                    self._state.discard(state)\n1977\t                if modifier in key:\n1979\t            self._on_key_release(event)\n1980\n1982\t        \"\"\"Key release event handler.\"\"\"\n1984\t    def set_visible(self, visible):\n1986\t        self.visible = visible\n1989\n1987\t        for artist in self.artists:\n1990",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "grep -n \"def update\" lib/matplotlib/widgets.py || true",
      "original": "1807:    def update_background(self, event):\n1862:    def update(self):\n",
      "perturbed": "1862:    def update(self):",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "sed -n '1858,1896p' lib/matplotlib/widgets.py",
      "original": "        # If a button was pressed, check if the release-button is the same.\n        return (event.inaxes != self.ax or\n                event.button != self._eventpress.button)\n\n    def update(self):\n        \"\"\"Draw using blit() or draw_idle(), depending on ``self.useblit``.\"\"\"\n        if not self.ax.get_visible() or self.ax.figure._cachedRenderer is None:\n            return False\n        if self.useblit:\n            if self.background is not None:\n                self.canvas.restore_region(self.background)\n            else:\n                self.update_background(None)\n            for artist in self.artists:\n                self.ax.draw_artist(artist)\n            self.canvas.blit(self.ax.bbox)\n        else:\n            self.canvas.draw_idle()\n        return False\n\n    def _get_data(self, event):\n        \"\"\"Get the xdata and ydata for event, with limits.\"\"\"\n        if event.xdata is None:\n            return None, None\n        xdata = np.clip(event.xdata, *self.ax.get_xbound())\n        ydata = np.clip(event.ydata, *self.ax.get_ybound())\n        return xdata, ydata\n\n    def _clean_event(self, event):\n        \"\"\"\n        Preprocess an event:\n\n        - Replace *event* by the previous event if *event* has no ``xdata``.\n        - Clip ``xdata`` and ``ydata`` to the axes limits.\n        - Update the previous event.\n        \"\"\"\n        if event.xdata is None:\n            event = self._prev_event\n        else:\n",
      "perturbed": "return (event.inaxes != self.ax or\n# If a button was pressed, check if the release-button is the same.\ndef update(self):\n\"\"\"Draw using blit() or draw_idle(), ...\nif self.useblit:\nif not self.ax.get_visible() or self.ax.figure._cachedRenderer is None:\nif self.background is not None:\nself.canvas.restore_region(self.background)\nelse:\nreturn False\nself.canvas.draw_idle()\ndef _get_data(self, event):\n\"\"\"Get the xdata and ydata for event, with limits.\"\"\"\nif event.xdata is None:\nxdata = np.clip(event.xdata, *self.ax.get_xbound())\nydata = np.clip(event.ydata, *self.ax.get_ybound())\nreturn xdata, ydata\n\"\"\"\ndef _clean_event(self, event):\nPreprocess an event:\n- Replace *event* ...\n- Clip ``xdata`` and ``ydata`` to the axes limits.\n- Update the previous event.\n\"\"\"\nif event.xdata is None:\nevent = self._prev_event",
      "applied_operators": [
        "text_perturbation"
      ]
    }
  ]
}