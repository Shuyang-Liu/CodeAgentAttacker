{
  "info": {
    "total_observations": 22,
    "python_observations": 2,
    "text_observations": 20,
    "ast_operators_applied": 1,
    "text_perturbation_applied": 12,
    "skipped": 9
  },
  "perturbations": [
    {
      "action": "ls -la testbed",
      "original": "ls: cannot access 'testbed': No such file or directory\n",
      "perturbed": "ls: cannot access 'testbed': No such file or directory",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "grep -RIn \"source-read\" -n sphinx doc || true",
      "original": "sphinx/io.py:112:        # emit \"source-read\" event\nsphinx/io.py:114:        env.events.emit('source-read', env.docname, arg)\nsphinx/events.py:40:    'source-read': 'docname, source text',\nsphinx/ext/intersphinx.py:691:    app.connect('source-read', install_dispatcher)\nsphinx/ext/duration.py:84:    app.connect('source-read', on_source_read)\ndoc/extdev/appapi.rst:157:       app.connect('source-read', source_read_handler)\ndoc/extdev/appapi.rst:175:         6. source-read(app, docname, source)\ndoc/extdev/appapi.rst:251:.. event:: source-read (app, docname, source)\ndoc/conf.py:235:    app.connect('source-read', linkify_issues_in_changelog)\n",
      "perturbed": "sphinx/io.py:112:        # emit \"source-read\" event\nsphinx/events.py:40:    'source-read': 'docname, source text',\nsphinx/ext/duration.py:84:    app.connect('sourc...\nsphinx/ext/intersphinx.py:691:    app.connect('source-read', install_dispatcher)\ndoc/extdev/appapi.rst:157:       app.connect('source-read', source_read_handler)\ndoc/extdev/appapi.rst:175:         6....\ndoc/extdev/appapi.rst:251:.. event:: source-read (app, docname, source)\ndoc/conf.py:235:    app.connect('source-read', linkify_issues_in_changelog)",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba sphinx/io.py | sed -n '1,240p'",
      "original": "     1\t\"\"\"Input/Output files\"\"\"\n     2\tfrom __future__ import annotations\n     3\t\n     4\tfrom typing import TYPE_CHECKING, Any\n     5\t\n     6\timport docutils\n     7\tfrom docutils import nodes\n     8\tfrom docutils.core import Publisher\n     9\tfrom docutils.io import FileInput, Input, NullOutput\n    10\tfrom docutils.readers import standalone\n    11\tfrom docutils.transforms.references import DanglingReferences\n    12\tfrom docutils.writers import UnfilteredWriter\n    13\t\n    14\tfrom sphinx import addnodes\n    15\tfrom sphinx.transforms import AutoIndexUpgrader, DoctreeReadEvent, SphinxTransformer\n    16\tfrom sphinx.transforms.i18n import (\n    17\t    Locale,\n    18\t    PreserveTranslatableMessages,\n    19\t    RemoveTranslatableInline,\n    20\t)\n    21\tfrom sphinx.transforms.references import SphinxDomains\n    22\tfrom sphinx.util import logging\n    23\tfrom sphinx.util.docutils import LoggingReporter\n    24\tfrom sphinx.versioning import UIDTransform\n    25\t\n    26\tif TYPE_CHECKING:\n    27\t    from docutils.frontend import Values\n    28\t    from docutils.parsers import Parser\n    29\t    from docutils.transforms import Transform\n    30\t\n    31\t    from sphinx.application import Sphinx\n    32\t    from sphinx.environment import BuildEnvironment\n    33\t\n    34\t\n    35\tlogger = logging.getLogger(__name__)\n    36\t\n    37\t\n    38\tclass SphinxBaseReader(standalone.Reader):\n    39\t    \"\"\"\n    40\t    A base class of readers for Sphinx.\n    41\t\n    42\t    This replaces reporter by Sphinx's on generating document.\n    43\t    \"\"\"\n    44\t\n    45\t    transforms: list[type[Transform]] = []\n    46\t\n    47\t    def __init__(self, *args: Any, **kwargs: Any) -> None:\n    48\t        from sphinx.application import Sphinx\n    49\t        if len(args) > 0 and isinstance(args[0], Sphinx):\n    50\t            self._app = args[0]\n    51\t            self._env = self._app.env\n    52\t            args = args[1:]\n    53\t\n    54\t        super().__init__(*args, **kwargs)\n    55\t\n    56\t    def setup(self, app: Sphinx) -> None:\n    57\t        self._app = app      # hold application object only for compatibility\n    58\t        self._env = app.env\n    59\t\n    60\t    def get_transforms(self) -> list[type[Transform]]:\n    61\t        transforms = super().get_transforms() + self.transforms\n    62\t\n    63\t        # remove transforms which is not needed for Sphinx\n    64\t        unused = [DanglingReferences]\n    65\t        for transform in unused:\n    66\t            if transform in transforms:\n    67\t                transforms.remove(transform)\n    68\t\n    69\t        return transforms\n    70\t\n    71\t    def new_document(self) -> nodes.document:\n    72\t        \"\"\"\n    73\t        Creates a new document object which has a special reporter object good\n    74\t        for logging.\n    75\t        \"\"\"\n    76\t        document = super().new_document()\n    77\t        document.__class__ = addnodes.document  # replace the class with patched version\n    78\t\n    79\t        # substitute transformer\n    80\t        document.transformer = SphinxTransformer(document)\n    81\t        document.transformer.set_environment(self.settings.env)\n    82\t\n    83\t        # substitute reporter\n    84\t        reporter = document.reporter\n    85\t        document.reporter = LoggingReporter.from_reporter(reporter)\n    86\t\n    87\t        return document\n    88\t\n    89\t\n    90\tclass SphinxStandaloneReader(SphinxBaseReader):\n    91\t    \"\"\"\n    92\t    A basic document reader for Sphinx.\n    93\t    \"\"\"\n    94\t\n    95\t    def setup(self, app: Sphinx) -> None:\n    96\t        self.transforms = self.transforms + app.registry.get_transforms()\n    97\t        super().setup(app)\n    98\t\n    99\t    def read(self, source: Input, parser: Parser, settings: Values) -> nodes.document:\n   100\t        self.source = source\n   101\t        if not self.parser:\n   102\t            self.parser = parser\n   103\t        self.settings = settings\n   104\t        self.input = self.read_source(settings.env)\n   105\t        self.parse()\n   106\t        return self.document\n   107\t\n   108\t    def read_source(self, env: BuildEnvironment) -> str:\n   109\t        \"\"\"Read content from source and do post-process.\"\"\"\n   110\t        content = self.source.read()\n   111\t\n   112\t        # emit \"source-read\" event\n   113\t        arg = [content]\n   114\t        env.events.emit('source-read', env.docname, arg)\n   115\t        return arg[0]\n   116\t\n   117\t\n   118\tclass SphinxI18nReader(SphinxBaseReader):\n   119\t    \"\"\"\n   120\t    A document reader for i18n.\n   121\t\n   122\t    This returns the source line number of original text as current source line number\n   123\t    to let users know where the error happened.\n   124\t    Because the translated texts are partial and they don't have correct line numbers.\n   125\t    \"\"\"\n   126\t\n   127\t    def setup(self, app: Sphinx) -> None:\n   128\t        super().setup(app)\n   129\t\n   130\t        self.transforms = self.transforms + app.registry.get_transforms()\n   131\t        unused = [PreserveTranslatableMessages, Locale, RemoveTranslatableInline,\n   132\t                  AutoIndexUpgrader, SphinxDomains, DoctreeReadEvent,\n   133\t                  UIDTransform]\n   134\t        for transform in unused:\n   135\t            if transform in self.transforms:\n   136\t                self.transforms.remove(transform)\n   137\t\n   138\t\n   139\tclass SphinxDummyWriter(UnfilteredWriter):\n   140\t    \"\"\"Dummy writer module used for generating doctree.\"\"\"\n   141\t\n   142\t    supported = ('html',)  # needed to keep \"meta\" nodes\n   143\t\n   144\t    def translate(self) -> None:\n   145\t        pass\n   146\t\n   147\t\n   148\tdef SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:\n   149\t    \"\"\"Bypass source object as is to cheat Publisher.\"\"\"\n   150\t    return source\n   151\t\n   152\t\n   153\tclass SphinxFileInput(FileInput):\n   154\t    \"\"\"A basic FileInput for Sphinx.\"\"\"\n   155\t    def __init__(self, *args: Any, **kwargs: Any) -> None:\n   156\t        kwargs['error_handler'] = 'sphinx'\n   157\t        super().__init__(*args, **kwargs)\n   158\t\n   159\t\n   160\tdef create_publisher(app: Sphinx, filetype: str) -> Publisher:\n   161\t    reader = SphinxStandaloneReader()\n   162\t    reader.setup(app)\n   163\t\n   164\t    parser = app.registry.create_source_parser(app, filetype)\n   165\t    if parser.__class__.__name__ == 'CommonMarkParser' and parser.settings_spec == ():\n   166\t        # a workaround for recommonmark\n   167\t        #   If recommonmark.AutoStrictify is enabled, the parser invokes reST parser\n   168\t        #   internally.  But recommonmark-0.4.0 does not provide settings_spec for reST\n   169\t        #   parser.  As a workaround, this copies settings_spec for RSTParser to the\n   170\t        #   CommonMarkParser.\n   171\t        from docutils.parsers.rst import Parser as RSTParser\n   172\t\n   173\t        parser.settings_spec = RSTParser.settings_spec\n   174\t\n   175\t    pub = Publisher(\n   176\t        reader=reader,\n   177\t        parser=parser,\n   178\t        writer=SphinxDummyWriter(),\n   179\t        source_class=SphinxFileInput,\n   180\t        destination=NullOutput(),\n   181\t    )\n   182\t    # Propagate exceptions by default when used programmatically:\n   183\t    defaults = {\"traceback\": True, **app.env.settings}\n   184\t    # Set default settings\n   185\t    if docutils.__version_info__[:2] >= (0, 19):\n   186\t        pub.get_settings(**defaults)\n   187\t    else:\n   188\t        pub.settings = pub.setup_option_parser(**defaults).get_default_values()\n   189\t    return pub\n",
      "perturbed": "2\tfrom __future__ import annotations\n1\t\"\"\"Input/Output files\"\"\"\n4\tfrom typing import ...\n3\n5\n6\timport docutils\n7\tfrom docutils import nodes\n8\tfrom docutils.core import Publisher\n9\tfrom docutils.io import...\n11\tfrom docutils.transforms.references im...\n12\tfrom docutils.writers import UnfilteredWriter\n14\tfrom sphinx import addnodes\n13\n15\tfrom sphinx.transforms import AutoIndexUpgrader, DoctreeReadEvent, SphinxTransformer\n20\t)\n16\tfrom sphinx.transforms.i18n import (\n21\tfrom sphinx.transforms.references import SphinxDomains\n22\tfrom sphinx.util import logging\n23\tfrom sphinx.util.docutils import LoggingReporter\n27\t    from docutils.frontend import Values\n24\tfrom sphinx.versioning import UIDTran...\n31\t    from sphinx.application import Sphinx\n29\t    from docut...\n33\n32\t    from sphinx.environment import BuildEnvironment\n34\n35\tlogger = logging.getLogger(__name__)\n38\tclass SphinxBaseReader(sta...\n37\n42\t    This replaces reporter by Sphinx's on generating document.\n40\t    A base class of readers for Sphinx.\n43\t    \"\"\"\n46\n44\n48\t        from sphinx.application import Sphinx\n49\t        if len(args) > 0 and isinstance(args[0], Sphinx):\n51\t            self._env = self._app.env\n52\t            args = args[1:]\n53\n54\t        super...\n57\t        self._app = app      # hold application object only for compatibility\n56\t    def setup(self, app: Sphinx) -> None:\n59\n60\t    def get_transforms(self) -> list[type[Transform]]:\n61\t        transforms = super().get_transforms() + self.transforms\n62\n63\t        # remove transforms which is not needed for Sphinx\n64\t        unused = [DanglingReferences]\n66\t            if transform in transforms:\n69\t        return transforms\n67\t                transforms.remove(transform)\n70\n71\t    def new_document(self) -> nodes.document:\n72\t        \"\"\"\n74\t        for logging.\n75\t        \"\"\"\n76\t        document = super().new_document()\n77\t        document.__class__ = addnodes.document  # replace the class with patched version\n78\n79\t        # substitute transformer\n81\t        document.transformer.set_environment(self.settings.env)\n80\t        document.transformer = SphinxTransformer(document)\n83\t        # substitute reporter\n82\n84\t        reporter = document.reporter\n86\n87\t        return document\n88\n89\n90\tclass SphinxStandaloneReader(SphinxBaseReader):\n92\t    A basic document reader for Sphinx.\n95\t    def setup(self, app: Sphinx) -> None:\n93\t    \"\"\"\n97\t        super().setup(app)\n98\n99\t    def read(self, source: Input, parser: Parser, settings: Values) -> nodes.document:\n101\t        if not self.parser:\n100\t        self.source = source\n102\t            self.parser = parser\n103\t        self.settings = settings\n105\t        self.parse()\n106\t        return self.document\n109\t        \"\"\"Read content from source and do post-process.\"\"\"\n110\t        content = self.source.read()\n111\n113\t        arg = [content]\n112\t        # emit \"source-read\" event\n114\t        env.events.emit('source-read', env.docname, arg)\n116\n118\tclass SphinxI18nRe...\n117\n120\t    A document reader for i18n.\n121\n123\t    to let users know where the er...\n126\n125\t    \"\"\"\n127\t    def setup(self, app: Sphinx) -> None:\n130\t        self.transforms = self.transforms + app.registry.get_transforms()\n131\t        unused = [PreserveTranslatableMessages, Locale, RemoveTranslatableInline,\n132\t                  AutoIndexUpgrader, SphinxDomains, DoctreeReadEvent,\n133\t                  UIDTransform]\n134\t        for transform in unused:\n136\t                self.transforms.remove(transform)\n138\n137\n140\t    \"\"\"Dummy writer module used for generating doctree.\"\"\"\n141\n142\t    supported = ('html',)  # needed to keep \"meta\" nodes\n143\n144\t    def translate(self) -> None:\n145\t        pass\n146\n149\t    \"\"\"Bypass source object as is to cheat Publisher.\"\"\"\n147\n150\t    return source\n153\tclass SphinxFileInput(FileInput):\n154\t    \"\"\"A basic FileInput for Sphinx.\"\"\"\n155\t    def __init__(self, *args: Any, **kwargs: Any) -> None:\n156\t        kwargs['error_handler'] = 'sphinx'\n157\t        super().__init__(*args, **kwargs)\n158\n161\t    reader = Sphinx...\n160\tdef create_publisher(app: Sphinx, filetype: str) -> Publisher:\n163\n162\t    reader.setup(app)\n166\t        # a workaround for recommonmark\n168\t        #   internally.  But recommonmark-0.4.0 does not provide settings_spec for reST\n167\t        #   If recommonmark.AutoStrictify is enabled, the parser invokes reST parser\n171\t        from docutils.parsers.rst import Parser as RSTParser\n170\t        #   CommonMarkParser.\n172\n173\t        parser.settings_spec = RSTParser.settings_spec\n174\n175\t    pub = Publisher(\n176\t        reader=reader,\n177\t        parser=parser,\n179\t        source_class=SphinxFileInput,\n178\t        writer=SphinxDummyWriter(),\n180\t        destination=NullOutput(),\n181\t    )\n182\t    # Propagate excep...\n183\t    defaults = {\"traceback\": True, **app.env.settings}\n184\t    # Set default settings\n185\t    if docutils.__ver...\n186\t        pub.get_settings(**defa...\n187\t    else:\n189\t    return pub\n188\t        pub.settings = pub.setup_option_parser(**defaults).get_default_values()",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba sphinx/directives/other.py | sed -n '350,520p'",
      "original": "   350\t                nested_depth = surrounding_title_styles.index(title_style)\n   351\t            # Use these depths to determine where the nested sections should\n   352\t            # be placed in the doctree.\n   353\t            n_sects_to_raise = current_depth - nested_depth + 1\n   354\t            parent = cast(nodes.Element, self.state.parent)\n   355\t            for _i in range(n_sects_to_raise):\n   356\t                if parent.parent:\n   357\t                    parent = parent.parent\n   358\t            parent.append(node)\n   359\t            return []\n   360\t        finally:\n   361\t            memo.title_styles = surrounding_title_styles\n   362\t            memo.section_level = surrounding_section_level\n   363\t\n   364\t\n   365\tclass Include(BaseInclude, SphinxDirective):\n   366\t    \"\"\"\n   367\t    Like the standard \"Include\" directive, but interprets absolute paths\n   368\t    \"correctly\", i.e. relative to source directory.\n   369\t    \"\"\"\n   370\t\n   371\t    def run(self) -> list[Node]:\n   372\t        if self.arguments[0].startswith('<') and \\\n   373\t           self.arguments[0].endswith('>'):\n   374\t            # docutils \"standard\" includes, do not do path processing\n   375\t            return super().run()\n   376\t        rel_filename, filename = self.env.relfn2path(self.arguments[0])\n   377\t        self.arguments[0] = filename\n   378\t        self.env.note_included(filename)\n   379\t        return super().run()\n   380\t\n   381\t\n   382\tdef setup(app: Sphinx) -> dict[str, Any]:\n   383\t    directives.register_directive('toctree', TocTree)\n   384\t    directives.register_directive('sectionauthor', Author)\n   385\t    directives.register_directive('moduleauthor', Author)\n   386\t    directives.register_directive('codeauthor', Author)\n   387\t    directives.register_directive('seealso', SeeAlso)\n   388\t    directives.register_directive('tabularcolumns', TabularColumns)\n   389\t    directives.register_directive('centered', Centered)\n   390\t    directives.register_directive('acks', Acks)\n   391\t    directives.register_directive('hlist', HList)\n   392\t    directives.register_directive('only', Only)\n   393\t    directives.register_directive('include', Include)\n   394\t\n   395\t    # register the standard rst class directive under a different name\n   396\t    # only for backwards compatibility now\n   397\t    directives.register_directive('cssclass', Class)\n   398\t    # new standard name when default-domain with \"class\" is in effect\n   399\t    directives.register_directive('rst-class', Class)\n   400\t\n   401\t    return {\n   402\t        'version': 'builtin',\n   403\t        'parallel_read_safe': True,\n   404\t        'parallel_write_safe': True,\n   405\t    }\n",
      "perturbed": "352\t            # be placed in the doctree.\n350\t                nested_depth = surrounding_title_styles.index(title_style)\n354\t            parent = cast(nodes.Element, self.state.parent)\n356\t                if parent.parent:\n357\t                    parent = parent.parent\n359\t            return []\n358\t            parent.append(node)\n360\t        finally:\n362\t            memo.section_level = surrounding_section_level\n361\t            memo.title_styles = surrounding_title_styles\n368\t    \"correctly\", i.e. relative to source directory.\n366\t    \"\"\"\n370\n369\t    \"\"\"\n371\t    def run(self) -> list[Node]:\n372\t        if self.arguments[0].startswith(...\n373\t           self.arguments[0].endswith('>'):\n374\t            # docutils \"standard\" includes, do not do path processing\n376\t        rel_filename, filename = self.env.relfn2path(self.arguments[0])\n378\t        self.env.note_included(filename)\n377\t        self.arguments[0] = filename\n380\n381\n383\t    directives.register_directive('toctree', TocTree)\n384\t    directives.register_directive('sectionauthor', Author)\n385\t    directives.register_directive('moduleauthor', Author)\n387\t    directives.register_directive('seealso', S...\n388\t    directives.register_directive('tabularcolumns', Ta...\n389\t    directives.register_directive('centered', Centered)\n391\t    directives.register_directive('hlist', HList)\n390\t    directives.register_directive('acks', Acks)\n392\t    directives.register_directive('only', Only)\n393\t    directives.register_directive('include', Include)\n394\n395\t    # register the stan...\n396\t    # only for backwards compatibility now\n397\t    directives.register_directive('cssclass', Class)\n398\t    # new standard name when default-domain with \"class\" is in effect\n399\t    directives.register_directive('rst-class', Class)\n401\t    return {\n400\n402\t        'version': 'builtin',\n403\t        'parallel_read_safe': True,\n404\t        'parallel_write_safe': True,\n405\t    }",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "grep -n \"class Include\" sphinx/directives/other.py",
      "original": "365:class Include(BaseInclude, SphinxDirective):\n",
      "perturbed": "365:class Include(BaseInclude, SphinxDirective):",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba sphinx/directives/other.py | sed -n '360,460p'",
      "original": "   360\t        finally:\n   361\t            memo.title_styles = surrounding_title_styles\n   362\t            memo.section_level = surrounding_section_level\n   363\t\n   364\t\n   365\tclass Include(BaseInclude, SphinxDirective):\n   366\t    \"\"\"\n   367\t    Like the standard \"Include\" directive, but interprets absolute paths\n   368\t    \"correctly\", i.e. relative to source directory.\n   369\t    \"\"\"\n   370\t\n   371\t    def run(self) -> list[Node]:\n   372\t        if self.arguments[0].startswith('<') and \\\n   373\t           self.arguments[0].endswith('>'):\n   374\t            # docutils \"standard\" includes, do not do path processing\n   375\t            return super().run()\n   376\t        rel_filename, filename = self.env.relfn2path(self.arguments[0])\n   377\t        self.arguments[0] = filename\n   378\t        self.env.note_included(filename)\n   379\t        return super().run()\n   380\t\n   381\t\n   382\tdef setup(app: Sphinx) -> dict[str, Any]:\n   383\t    directives.register_directive('toctree', TocTree)\n   384\t    directives.register_directive('sectionauthor', Author)\n   385\t    directives.register_directive('moduleauthor', Author)\n   386\t    directives.register_directive('codeauthor', Author)\n   387\t    directives.register_directive('seealso', SeeAlso)\n   388\t    directives.register_directive('tabularcolumns', TabularColumns)\n   389\t    directives.register_directive('centered', Centered)\n   390\t    directives.register_directive('acks', Acks)\n   391\t    directives.register_directive('hlist', HList)\n   392\t    directives.register_directive('only', Only)\n   393\t    directives.register_directive('include', Include)\n   394\t\n   395\t    # register the standard rst class directive under a different name\n   396\t    # only for backwards compatibility now\n   397\t    directives.register_directive('cssclass', Class)\n   398\t    # new standard name when default-domain with \"class\" is in effect\n   399\t    directives.register_directive('rst-class', Class)\n   400\t\n   401\t    return {\n   402\t        'version': 'builtin',\n   403\t        'parallel_read_safe': True,\n   404\t        'parallel_write_safe': True,\n   405\t    }\n",
      "perturbed": "361\t            memo.title_styles = surrounding_title_styles\n363\n362\t            memo.section...\n364\n366\t    \"\"\"\n365\tclass Include(BaseInclude, SphinxDirective):\n369\t    \"\"\"\n370\n371\t    def run(self) -> list[Node]:\n373\t           self.arguments[0].endswith('>'):\n372\t        if self.arguments[0].startswith('<') and \\\n374\t            # docutils \"standard\" includes, do not do path processing\n375\t            return super().run()\n376\t        rel_filename, filename = self.env.relfn2path(self.arguments[0])\n377\t        self.arguments[0] = filename\n379\t        return super().run()\n378\t        self.env.note_included(filename)\n380\n382\tdef setup(app: Sphinx) -> dict[str, Any]:\n384\t    directives.regi...\n383\t    directives.register_directive('toctree', TocTree)\n385\t    directives.register_directive('moduleauthor', Author)\n387\t    directives.register_directive('seealso', SeeAlso)\n390\t    directives.register_directive('acks', Acks)\n391\t    directives.register_directiv...\n392\t    directives.register_directive('only', Only)\n393\t    directives.register_directive('include', Include)\n396\t    # only for backwards compatibility now\n395\t    # register the standard rst class directive under a different name\n397\t    directives.register_directive('cssclass', Class)\n398\t    # new standard name when default-domain with \"class\" is in effect\n399\t    directives.register_directive('rst-class', Class)\n400\n401\t    return {\n402\t        'version': 'builtin',\n403\t        'parallel_read_safe': True,",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "python - <<'PY'\nimport inspect, docutils.parsers.rst.directives.misc as m\nprint(inspect.getsource(m.Include))\nPY",
      "original": "class Include(Directive):\n\n    \"\"\"\n    Include content read from a separate source file.\n\n    Content may be parsed by the parser, or included as a literal\n    block.  The encoding of the included file can be specified.  Only\n    a part of the given file argument may be included by specifying\n    start and end line or text to match before and/or after the text\n    to be used.\n\n    https://docutils.sourceforge.io/docs/ref/rst/directives.html#including-an-external-document-fragment\n    \"\"\"\n\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = True\n    option_spec = {'literal': directives.flag,\n                   'code': directives.unchanged,\n                   'encoding': directives.encoding,\n                   'parser': directives.parser_name,\n                   'tab-width': int,\n                   'start-line': int,\n                   'end-line': int,\n                   'start-after': directives.unchanged_required,\n                   'end-before': directives.unchanged_required,\n                   # ignored except for 'literal' or 'code':\n                   'number-lines': directives.unchanged,  # integer or None\n                   'class': directives.class_option,\n                   'name': directives.unchanged}\n\n    standard_include_path = Path(states.__file__).parent / 'include'\n\n    def run(self):\n        \"\"\"Include a file as part of the content of this reST file.\n\n        Depending on the options, the file (or a clipping) is\n        converted to nodes and returned or inserted into the input stream.\n        \"\"\"\n        if not self.state.document.settings.file_insertion_enabled:\n            raise self.warning('\"%s\" directive disabled.' % self.name)\n        current_source = self.state.document.current_source\n        path = directives.path(self.arguments[0])\n        if path.startswith('<') and path.endswith('>'):\n            _base = self.standard_include_path\n            path = path[1:-1]\n        else:\n            _base = Path(current_source).parent\n        path = utils.relative_path(None, _base/path)\n        encoding = self.options.get(\n            'encoding', self.state.document.settings.input_encoding)\n        e_handler = self.state.document.settings.input_encoding_error_handler\n        tab_width = self.options.get(\n            'tab-width', self.state.document.settings.tab_width)\n        try:\n            include_file = io.FileInput(source_path=path,\n                                        encoding=encoding,\n                                        error_handler=e_handler)\n        except UnicodeEncodeError:\n            raise self.severe(f'Problems with \"{self.name}\" directive path:\\n'\n                              f'Cannot encode input file path \"{path}\" '\n                              '(wrong locale?).')\n        except OSError as error:\n            raise self.severe(f'Problems with \"{self.name}\" directive '\n                              f'path:\\n{io.error_string(error)}.')\n        else:\n            self.state.document.settings.record_dependencies.add(path)\n\n        # Get to-be-included content\n        startline = self.options.get('start-line', None)\n        endline = self.options.get('end-line', None)\n        try:\n            if startline or (endline is not None):\n                lines = include_file.readlines()\n                rawtext = ''.join(lines[startline:endline])\n            else:\n                rawtext = include_file.read()\n        except UnicodeError as error:\n            raise self.severe(f'Problem with \"{self.name}\" directive:\\n'\n                              + io.error_string(error))\n        # start-after/end-before: no restrictions on newlines in match-text,\n        # and no restrictions on matching inside lines vs. line boundaries\n        after_text = self.options.get('start-after', None)\n        if after_text:\n            # skip content in rawtext before *and incl.* a matching text\n            after_index = rawtext.find(after_text)\n            if after_index < 0:\n                raise self.severe('Problem with \"start-after\" option of \"%s\" '\n                                  'directive:\\nText not found.' % self.name)\n            rawtext = rawtext[after_index + len(after_text):]\n        before_text = self.options.get('end-before', None)\n        if before_text:\n            # skip content in rawtext after *and incl.* a matching text\n            before_index = rawtext.find(before_text)\n            if before_index < 0:\n                raise self.severe('Problem with \"end-before\" option of \"%s\" '\n                                  'directive:\\nText not found.' % self.name)\n            rawtext = rawtext[:before_index]\n\n        include_lines = statemachine.string2lines(rawtext, tab_width,\n                                                  convert_whitespace=True)\n        for i, line in enumerate(include_lines):\n            if len(line) > self.state.document.settings.line_length_limit:\n                raise self.warning('\"%s\": line %d exceeds the'\n                                   ' line-length-limit.' % (path, i+1))\n\n        if 'literal' in self.options:\n            # Don't convert tabs to spaces, if `tab_width` is negative.\n            if tab_width >= 0:\n                text = rawtext.expandtabs(tab_width)\n            else:\n                text = rawtext\n            literal_block = nodes.literal_block(\n                                rawtext, source=path,\n                                classes=self.options.get('class', []))\n            literal_block.line = 1\n            self.add_name(literal_block)\n            if 'number-lines' in self.options:\n                try:\n                    startline = int(self.options['number-lines'] or 1)\n                except ValueError:\n                    raise self.error(':number-lines: with non-integer '\n                                     'start value')\n                endline = startline + len(include_lines)\n                if text.endswith('\\n'):\n                    text = text[:-1]\n                tokens = NumberLines([([], text)], startline, endline)\n                for classes, value in tokens:\n                    if classes:\n                        literal_block += nodes.inline(value, value,\n                                                      classes=classes)\n                    else:\n                        literal_block += nodes.Text(value)\n            else:\n                literal_block += nodes.Text(text)\n            return [literal_block]\n\n        if 'code' in self.options:\n            self.options['source'] = path\n            # Don't convert tabs to spaces, if `tab_width` is negative:\n            if tab_width < 0:\n                include_lines = rawtext.splitlines()\n            codeblock = CodeBlock(self.name,\n                                  [self.options.pop('code')],  # arguments\n                                  self.options,\n                                  include_lines,  # content\n                                  self.lineno,\n                                  self.content_offset,\n                                  self.block_text,\n                                  self.state,\n                                  self.state_machine)\n            return codeblock.run()\n\n        # Prevent circular inclusion:\n        clip_options = (startline, endline, before_text, after_text)\n        include_log = self.state.document.include_log\n        # log entries are tuples (<source>, <clip-options>)\n        if not include_log:  # new document, initialize with document source\n            include_log.append((utils.relative_path(None, current_source),\n                                (None, None, None, None)))\n        if (path, clip_options) in include_log:\n            master_paths = (pth for (pth, opt) in reversed(include_log))\n            inclusion_chain = '\\n> '.join((path, *master_paths))\n            raise self.warning('circular inclusion in \"%s\" directive:\\n%s'\n                               % (self.name, inclusion_chain))\n\n        if 'parser' in self.options:\n            # parse into a dummy document and return created nodes\n            document = utils.new_document(path, self.state.document.settings)\n            document.include_log = include_log + [(path, clip_options)]\n            parser = self.options['parser']()\n            parser.parse('\\n'.join(include_lines), document)\n            # clean up doctree and complete parsing\n            document.transformer.populate_from_components((parser,))\n            document.transformer.apply_transforms()\n            return document.children\n\n        # Include as rST source:\n        #\n        # mark end (cf. parsers.rst.states.Body.comment())\n        include_lines += ['', '.. end of inclusion from \"%s\"' % path]\n        self.state_machine.insert_input(include_lines, path)\n        # update include-log\n        include_log.append((path, clip_options))\n        return []\n\n",
      "perturbed": "class Include(Directive):\n    \"\"\"\n    Include content read from a separate source file.\n\n    Content may be parsed by the parser, or included as a literal\n    block.  The encoding of the included file can be specified.  Only\n    a part of the given file argument may be included by specifying\n    start and end line or text to match before and/or after the text\n    to be used.\n\n    https://docutils.sourceforge.io/docs/ref/rst/directives.html#including-an-external-document-fragment\n    \"\"\"\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = True\n    option_spec = {'literal': directives.flag, 'code': directives.unchanged, 'encoding': directives.encoding, 'parser': directives.parser_name, 'tab-width': int, 'start-line': int, 'end-line': int, 'start-after': directives.unchanged_required, 'end-before': directives.unchanged_required, 'number-lines': directives.unchanged, 'class': directives.class_option, 'name': directives.unchanged}\n    standard_include_path = Path(states.__file__).parent / 'include'\n\n    def run(self):\n        \"\"\"Include a file as part of the content of this reST file.\n\n        Depending on the options, the file (or a clipping) is\n        converted to nodes and returned or inserted into the input stream.\n        \"\"\"\n        if not self.state.document.settings.file_insertion_enabled:\n            raise self.warning('\"%s\" directive disabled.' % self.name)\n        current_source = self.state.document.current_source\n        path = directives.path(self.arguments[0])\n        if path.startswith('<') and path.endswith('>'):\n            _base = self.standard_include_path\n            path = path[1:-1]\n        else:\n            _base = Path(current_source).parent\n        path = utils.relative_path(None, _base / path)\n        encoding = self.options.get('encoding', self.state.document.settings.input_encoding)\n        e_handler = self.state.document.settings.input_encoding_error_handler\n        tab_width = self.options.get('tab-width', self.state.document.settings.tab_width)\n        include_file = io.FileInput(source_path=path, encoding=encoding, error_handler=e_handler)\n        startline = self.options.get('start-line', None)\n        endline = self.options.get('end-line', None)\n        if startline or endline is not None:\n            lines = include_file.readlines()\n            rawtext = ''.join(lines[startline:endline])\n        else:\n            rawtext = include_file.read()\n        after_text = self.options.get('start-after', None)\n        if after_text:\n            after_index = rawtext.find(after_text)\n            if after_index < 0:\n                raise self.severe('Problem with \"start-after\" option of \"%s\" directive:\\nText not found.' % self.name)\n            rawtext = rawtext[after_index + len(after_text):]\n        before_text = self.options.get('end-before', None)\n        if before_text:\n            before_index = rawtext.find(before_text)\n            if before_index < 0:\n                raise self.severe('Problem with \"end-before\" option of \"%s\" directive:\\nText not found.' % self.name)\n            rawtext = rawtext[:before_index]\n        include_lines = statemachine.string2lines(rawtext, tab_width, convert_whitespace=True)\n        for i, line in enumerate(include_lines):\n            if len(line) > self.state.document.settings.line_length_limit:\n                raise self.warning('\"%s\": line %d exceeds the line-length-limit.' % (path, i + 1))\n        if 'literal' in self.options:\n            if tab_width >= 0:\n                text = rawtext.expandtabs(tab_width)\n            else:\n                text = rawtext\n            literal_block = nodes.literal_block(rawtext, source=path, classes=self.options.get('class', []))\n            literal_block.line = 1\n            self.add_name(literal_block)\n            if 'number-lines' in self.options:\n                startline = int(self.options['number-lines'] or 1)\n                endline = startline + len(include_lines)\n                if text.endswith('\\n'):\n                    text = text[:-1]\n                tokens = NumberLines([([], text)], startline, endline)\n                for classes, value in tokens:\n                    if classes:\n                        literal_block += nodes.inline(value, value, classes=classes)\n                    else:\n                        literal_block += nodes.Text(value)\n            else:\n                literal_block += nodes.Text(text)\n            return [literal_block]\n        if 'code' in self.options:\n            self.options['source'] = path\n            if tab_width < 0:\n                include_lines = rawtext.splitlines()\n            codeblock = CodeBlock(self.name, [self.options.pop('code')], self.options, include_lines, self.lineno, self.content_offset, self.block_text, self.state, self.state_machine)\n            return codeblock.run()\n        clip_options = (startline, endline, before_text, after_text)\n        include_log = self.state.document.include_log\n        if not include_log:\n            include_log.append((utils.relative_path(None, current_source), (None, None, None, None)))\n        if (path, clip_options) in include_log:\n            master_paths = (pth for pth, opt in reversed(include_log))\n            inclusion_chain = '\\n> '.join((path, *master_paths))\n            raise self.warning('circular inclusion in \"%s\" directive:\\n%s' % (self.name, inclusion_chain))\n        if 'parser' in self.options:\n            document = utils.new_document(path, self.state.document.settings)\n            document.include_log = include_log + [(path, clip_options)]\n            parser = self.options['parser']()\n            parser.parse('\\n'.join(include_lines), document)\n            document.transformer.populate_from_components((parser,))\n            document.transformer.apply_transforms()\n            return document.children\n        include_lines += ['', '.. end of inclusion from \"%s\"' % path]\n        self.state_machine.insert_input(include_lines, path)\n        include_log.append((path, clip_options))\n        return []",
      "applied_operators": [
        "apr_remove_try_except"
      ]
    },
    {
      "action": "nl -ba sphinx/io.py | sed -n '140,220p'",
      "original": "   140\t    \"\"\"Dummy writer module used for generating doctree.\"\"\"\n   141\t\n   142\t    supported = ('html',)  # needed to keep \"meta\" nodes\n   143\t\n   144\t    def translate(self) -> None:\n   145\t        pass\n   146\t\n   147\t\n   148\tdef SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:\n   149\t    \"\"\"Bypass source object as is to cheat Publisher.\"\"\"\n   150\t    return source\n   151\t\n   152\t\n   153\tclass SphinxFileInput(FileInput):\n   154\t    \"\"\"A basic FileInput for Sphinx.\"\"\"\n   155\t    def __init__(self, *args: Any, **kwargs: Any) -> None:\n   156\t        kwargs['error_handler'] = 'sphinx'\n   157\t        super().__init__(*args, **kwargs)\n   158\t\n   159\t\n   160\tdef create_publisher(app: Sphinx, filetype: str) -> Publisher:\n   161\t    reader = SphinxStandaloneReader()\n   162\t    reader.setup(app)\n   163\t\n   164\t    parser = app.registry.create_source_parser(app, filetype)\n   165\t    if parser.__class__.__name__ == 'CommonMarkParser' and parser.settings_spec == ():\n   166\t        # a workaround for recommonmark\n   167\t        #   If recommonmark.AutoStrictify is enabled, the parser invokes reST parser\n   168\t        #   internally.  But recommonmark-0.4.0 does not provide settings_spec for reST\n   169\t        #   parser.  As a workaround, this copies settings_spec for RSTParser to the\n   170\t        #   CommonMarkParser.\n   171\t        from docutils.parsers.rst import Parser as RSTParser\n   172\t\n   173\t        parser.settings_spec = RSTParser.settings_spec\n   174\t\n   175\t    pub = Publisher(\n   176\t        reader=reader,\n   177\t        parser=parser,\n   178\t        writer=SphinxDummyWriter(),\n   179\t        source_class=SphinxFileInput,\n   180\t        destination=NullOutput(),\n   181\t    )\n   182\t    # Propagate exceptions by default when used programmatically:\n   183\t    defaults = {\"traceback\": True, **app.env.settings}\n   184\t    # Set default settings\n   185\t    if docutils.__version_info__[:2] >= (0, 19):\n   186\t        pub.get_settings(**defaults)\n   187\t    else:\n   188\t        pub.settings = pub.setup_option_parser(**defaults).get_default_values()\n   189\t    return pub\n",
      "perturbed": "141\n140\t    \"\"\"Dummy writer module...\n144\t    def translate(self) -> None:\n145\t        pass\n146\n148\tdef SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:\n149\t    \"\"\"Bypass source object as is to cheat Publisher.\"\"\"\n150\t    return source\n151\n152\n153\tclass SphinxFileInput(FileInput):\n155\t    def __init__(self, *args: Any, **kwargs: Any) -> None:\n156\t        kwargs['er...\n157\t        super().__init__(*args, **kwargs)\n158\n159\n160\tdef create_publisher(app: Sphinx, filetype: str) -> Publisher:\n161\t    reader = SphinxStandaloneReader()\n162\t    reader.setup(app)\n163\n164\t    parser = app.registry...\n165\t    if parser.__class__.__name__ == 'CommonMarkParser' and parser.settings_spec == ():\n166\t        # a workaround for...\n168\t        #   internally.  But recommonmark-0.4.0 does not provide settings_spec for reST\n167\t        #   If recommonmark.AutoStrictify is enabled, the parser invokes reST parser\n169\t        #   parser.  As a workaround, this c...\n171\t        from docutils.parsers.rst import Parser as RSTParser\n170\t        #   CommonMarkParser.\n172\n173\t        parser.settings_spec = R...\n175\t    pub = Publisher(\n179\t        source_class=SphinxFileInput,\n177\t        parser=parser,\n180\t        destination=NullOutput(),\n182\t    # Propagate exceptions by default when used programmatically:\n181\t    )\n184\t    # Set default settings\n188\t        pub.settings = pub.setup_option_parser(**defaults).get_default_values()\n187\t    else:\n189\t    return pub",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba sphinx/io.py | sed -n '130,200p'",
      "original": "   130\t        self.transforms = self.transforms + app.registry.get_transforms()\n   131\t        unused = [PreserveTranslatableMessages, Locale, RemoveTranslatableInline,\n   132\t                  AutoIndexUpgrader, SphinxDomains, DoctreeReadEvent,\n   133\t                  UIDTransform]\n   134\t        for transform in unused:\n   135\t            if transform in self.transforms:\n   136\t                self.transforms.remove(transform)\n   137\t\n   138\t\n   139\tclass SphinxDummyWriter(UnfilteredWriter):\n   140\t    \"\"\"Dummy writer module used for generating doctree.\"\"\"\n   141\t\n   142\t    supported = ('html',)  # needed to keep \"meta\" nodes\n   143\t\n   144\t    def translate(self) -> None:\n   145\t        pass\n   146\t\n   147\t\n   148\tdef SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:\n   149\t    \"\"\"Bypass source object as is to cheat Publisher.\"\"\"\n   150\t    return source\n   151\t\n   152\t\n   153\tclass SphinxFileInput(FileInput):\n   154\t    \"\"\"A basic FileInput for Sphinx.\"\"\"\n   155\t    def __init__(self, *args: Any, **kwargs: Any) -> None:\n   156\t        kwargs['error_handler'] = 'sphinx'\n   157\t        super().__init__(*args, **kwargs)\n   158\t\n   159\t\n   160\tdef create_publisher(app: Sphinx, filetype: str) -> Publisher:\n   161\t    reader = SphinxStandaloneReader()\n   162\t    reader.setup(app)\n   163\t\n   164\t    parser = app.registry.create_source_parser(app, filetype)\n   165\t    if parser.__class__.__name__ == 'CommonMarkParser' and parser.settings_spec == ():\n   166\t        # a workaround for recommonmark\n   167\t        #   If recommonmark.AutoStrictify is enabled, the parser invokes reST parser\n   168\t        #   internally.  But recommonmark-0.4.0 does not provide settings_spec for reST\n   169\t        #   parser.  As a workaround, this copies settings_spec for RSTParser to the\n   170\t        #   CommonMarkParser.\n   171\t        from docutils.parsers.rst import Parser as RSTParser\n   172\t\n   173\t        parser.settings_spec = RSTParser.settings_spec\n   174\t\n   175\t    pub = Publisher(\n   176\t        reader=reader,\n   177\t        parser=parser,\n   178\t        writer=SphinxDummyWriter(),\n   179\t        source_class=SphinxFileInput,\n   180\t        destination=NullOutput(),\n   181\t    )\n   182\t    # Propagate exceptions by default when used programmatically:\n   183\t    defaults = {\"traceback\": True, **app.env.settings}\n   184\t    # Set default settings\n   185\t    if docutils.__version_info__[:2] >= (0, 19):\n   186\t        pub.get_settings(**defaults)\n   187\t    else:\n   188\t        pub.settings = pub.setup_option_parser(**defaults).get_default_values()\n   189\t    return pub\n",
      "perturbed": "130\t        self.transforms = self.transforms + app.registry.get_transforms()\n131\t        unused = [PreserveTranslatableMessages, Locale, RemoveTranslatableInline,\n134\t        for transform in unused:\n132\t                  AutoIndexUpgrader, SphinxDomains, DoctreeReadEvent,\n135\t            if transform in self.transforms:\n136\t                self.transforms.remove(transform)\n137\n138\n142\t    supported = ('html',)  # needed to keep \"meta\" nodes\n143\n144\t    def translate(self) -> None:\n146\n148\tdef SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:\n147\n149\t    \"\"\"Bypass source object as is to cheat Publisher.\"\"\"\n150\t    return source\n155\t    def __init__(self, *args: Any, **kwargs: Any) -> None:\n151\n157\t        super().__init__(*args, **kwargs)\n158\n159\n161\t    reader = ...\n162\t    reader.setup(app)\n165\t    if parser.__class__.__name__ == 'CommonMarkParser' and parser.settings_spec == ():\n167\t        #   If recommonmark.AutoStrictify is enabled, the parser ...\n166\t        # a workaround for recommonmark\n168\t        #   internally.  But recommonmark-0.4.0 does not provide settings_spec for reST\n169\t        #   parser.  As a workaround, this copies settings_spec for RSTParser to the\n171\t        from docutils.parsers.rst import Parser as RSTParser\n174\n175\t    pub = Publisher(\n177\t        parser=parser,\n178\t        writer=SphinxDum...\n179\t        source_class=SphinxFileInput,\n180\t        destination=NullOutput(),\n181\t    )\n182\t    # Propagate exceptions by default when used programmatically:\n183\t    defaults = {\"traceback\": True, **app.env.settings}\n185\t    if docutils.__version_info__[:2] >= (0, 19):\n186\t        pub.get_settings(**defaults)\n187\t    else:",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "grep -n \"class SphinxFileInput\" -n sphinx/io.py && sed -n '1,240p' sphinx/io.py | sed -n '150,220p'",
      "original": "153:class SphinxFileInput(FileInput):\n    return source\n\n\nclass SphinxFileInput(FileInput):\n    \"\"\"A basic FileInput for Sphinx.\"\"\"\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        kwargs['error_handler'] = 'sphinx'\n        super().__init__(*args, **kwargs)\n\n\ndef create_publisher(app: Sphinx, filetype: str) -> Publisher:\n    reader = SphinxStandaloneReader()\n    reader.setup(app)\n\n    parser = app.registry.create_source_parser(app, filetype)\n    if parser.__class__.__name__ == 'CommonMarkParser' and parser.settings_spec == ():\n        # a workaround for recommonmark\n        #   If recommonmark.AutoStrictify is enabled, the parser invokes reST parser\n        #   internally.  But recommonmark-0.4.0 does not provide settings_spec for reST\n        #   parser.  As a workaround, this copies settings_spec for RSTParser to the\n        #   CommonMarkParser.\n        from docutils.parsers.rst import Parser as RSTParser\n\n        parser.settings_spec = RSTParser.settings_spec\n\n    pub = Publisher(\n        reader=reader,\n        parser=parser,\n        writer=SphinxDummyWriter(),\n        source_class=SphinxFileInput,\n        destination=NullOutput(),\n    )\n    # Propagate exceptions by default when used programmatically:\n    defaults = {\"traceback\": True, **app.env.settings}\n    # Set default settings\n    if docutils.__version_info__[:2] >= (0, 19):\n        pub.get_settings(**defaults)\n    else:\n        pub.settings = pub.setup_option_parser(**defaults).get_default_values()\n    return pub\n",
      "perturbed": "153:class SphinxFileInput(FileInput):\n\"\"\"A basic FileInput for Sphinx.\"\"\"\ndef __init__(self, *args: Any, **kwargs: Any) -> None:\nkwargs['error_...\nsuper().__init__(*args, **kwargs)\ndef create_publisher(app: Sphinx, filetype: str) -> Publisher:\nreader = SphinxStandaloneReader()\nreader.setup(app)\nparser = app.registry.create_source_parser(app, filetype)\n# a workaround for recommonmark\nif parser.__class__.__name__ == 'CommonMarkParser' and parser.settings_spec == ():\n#   parser.  As a workaround, this copies settings_spec for RSTParser to the\n#   If recommonmark.AutoStrictify is enabled, the parser invokes reST parser\nparser.settings_spec = RSTParser.setting...\n#   CommonMarkParser.\nreader=reader,\nparser=parser,\nwriter=SphinxDummyWriter(),\nsource_class=SphinxFileInput,\ndestination=NullOutput(),\n)\n# Propagate exceptions by default when used programmatically:\n# Set default settings\ndefaults = {\"traceback\": True, **app.env.settings}\nif docutils.__version_info__[:2] >= (0, 19):\npub.get_settings(**defaults)\nreturn pub\nelse:",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "pytest -q tests/test_directive_other.py::test_toctree_includefiles -q",
      "original": "\nERROR: not found: /testbed/tests/test_directive_other.py::test_toctree_includefiles\n(no match in any of [<Module test_directive_other.py>])\n\n",
      "perturbed": "(no match in any of [<Module test_directive_other.py>])\nnote: partial output truncated\ninfo: continuing execution",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba tests/test_directive_other.py | sed -n '1,240p'",
      "original": "     1\t\"\"\"Test the other directives.\"\"\"\n     2\t\n     3\timport pytest\n     4\tfrom docutils import nodes\n     5\t\n     6\tfrom sphinx import addnodes\n     7\tfrom sphinx.testing import restructuredtext\n     8\tfrom sphinx.testing.util import assert_node\n     9\t\n    10\t\n    11\t@pytest.mark.sphinx(testroot='toctree-glob')\n    12\tdef test_toctree(app):\n    13\t    text = (\".. toctree::\\n\"\n    14\t            \"\\n\"\n    15\t            \"   foo\\n\"\n    16\t            \"   bar/index\\n\"\n    17\t            \"   baz\\n\")\n    18\t\n    19\t    app.env.find_files(app.config, app.builder)\n    20\t    doctree = restructuredtext.parse(app, text, 'index')\n    21\t    assert_node(doctree, [nodes.document, nodes.compound, addnodes.toctree])\n    22\t    assert_node(doctree[0][0],\n    23\t                entries=[(None, 'foo'), (None, 'bar/index'), (None, 'baz')],\n    24\t                includefiles=['foo', 'bar/index', 'baz'])\n    25\t\n    26\t\n    27\t@pytest.mark.sphinx(testroot='toctree-glob')\n    28\tdef test_relative_toctree(app):\n    29\t    text = (\".. toctree::\\n\"\n    30\t            \"\\n\"\n    31\t            \"   bar_1\\n\"\n    32\t            \"   bar_2\\n\"\n    33\t            \"   bar_3\\n\"\n    34\t            \"   ../quux\\n\")\n    35\t\n    36\t    app.env.find_files(app.config, app.builder)\n    37\t    doctree = restructuredtext.parse(app, text, 'bar/index')\n    38\t    assert_node(doctree, [nodes.document, nodes.compound, addnodes.toctree])\n    39\t    assert_node(doctree[0][0],\n    40\t                entries=[(None, 'bar/bar_1'), (None, 'bar/bar_2'), (None, 'bar/bar_3'),\n    41\t                         (None, 'quux')],\n    42\t                includefiles=['bar/bar_1', 'bar/bar_2', 'bar/bar_3', 'quux'])\n    43\t\n    44\t\n    45\t@pytest.mark.sphinx(testroot='toctree-glob')\n    46\tdef test_toctree_urls_and_titles(app):\n    47\t    text = (\".. toctree::\\n\"\n    48\t            \"\\n\"\n    49\t            \"   Sphinx <https://www.sphinx-doc.org/>\\n\"\n    50\t            \"   https://readthedocs.org/\\n\"\n    51\t            \"   The BAR <bar/index>\\n\")\n    52\t\n    53\t    app.env.find_files(app.config, app.builder)\n    54\t    doctree = restructuredtext.parse(app, text, 'index')\n    55\t    assert_node(doctree, [nodes.document, nodes.compound, addnodes.toctree])\n    56\t    assert_node(doctree[0][0],\n    57\t                entries=[('Sphinx', 'https://www.sphinx-doc.org/'),\n    58\t                         (None, 'https://readthedocs.org/'),\n    59\t                         ('The BAR', 'bar/index')],\n    60\t                includefiles=['bar/index'])\n    61\t\n    62\t\n    63\t@pytest.mark.sphinx(testroot='toctree-glob')\n    64\tdef test_toctree_glob(app):\n    65\t    text = (\".. toctree::\\n\"\n    66\t            \"   :glob:\\n\"\n    67\t            \"\\n\"\n    68\t            \"   *\\n\")\n    69\t\n    70\t    app.env.find_files(app.config, app.builder)\n    71\t    doctree = restructuredtext.parse(app, text, 'index')\n    72\t    assert_node(doctree, [nodes.document, nodes.compound, addnodes.toctree])\n    73\t    assert_node(doctree[0][0],\n    74\t                entries=[(None, 'baz'), (None, 'foo'), (None, 'quux')],\n    75\t                includefiles=['baz', 'foo', 'quux'])\n    76\t\n    77\t    # give both docname and glob (case1)\n    78\t    text = (\".. toctree::\\n\"\n    79\t            \"   :glob:\\n\"\n    80\t            \"\\n\"\n    81\t            \"   foo\\n\"\n    82\t            \"   *\\n\")\n    83\t\n    84\t    app.env.find_files(app.config, app.builder)\n    85\t    doctree = restructuredtext.parse(app, text, 'index')\n    86\t    assert_node(doctree, [nodes.document, nodes.compound, addnodes.toctree])\n    87\t    assert_node(doctree[0][0],\n    88\t                entries=[(None, 'foo'), (None, 'baz'), (None, 'quux')],\n    89\t                includefiles=['foo', 'baz', 'quux'])\n    90\t\n    91\t    # give both docname and glob (case2)\n    92\t    text = (\".. toctree::\\n\"\n    93\t            \"   :glob:\\n\"\n    94\t            \"\\n\"\n    95\t            \"   *\\n\"\n    96\t            \"   foo\\n\")\n    97\t\n    98\t    app.env.find_files(app.config, app.builder)\n    99\t    doctree = restructuredtext.parse(app, text, 'index')\n   100\t    assert_node(doctree, [nodes.document, nodes.compound, addnodes.toctree])\n   101\t    assert_node(doctree[0][0],\n   102\t                entries=[(None, 'baz'), (None, 'foo'), (None, 'quux'), (None, 'foo')],\n   103\t                includefiles=['baz', 'foo', 'quux', 'foo'])\n   104\t\n   105\t\n   106\t@pytest.mark.sphinx(testroot='toctree-glob')\n   107\tdef test_toctree_glob_and_url(app):\n   108\t    text = (\".. toctree::\\n\"\n   109\t            \"   :glob:\\n\"\n   110\t            \"\\n\"\n   111\t            \"   https://example.com/?q=sphinx\\n\")\n   112\t\n   113\t    app.env.find_files(app.config, app.builder)\n   114\t    doctree = restructuredtext.parse(app, text, 'index')\n   115\t    assert_node(doctree, [nodes.document, nodes.compound, addnodes.toctree])\n   116\t    assert_node(doctree[0][0],\n   117\t                entries=[(None, 'https://example.com/?q=sphinx')],\n   118\t                includefiles=[])\n   119\t\n   120\t\n   121\t@pytest.mark.sphinx(testroot='toctree-glob')\n   122\tdef test_reversed_toctree(app):\n   123\t    text = (\".. toctree::\\n\"\n   124\t            \"   :reversed:\\n\"\n   125\t            \"\\n\"\n   126\t            \"   foo\\n\"\n   127\t            \"   bar/index\\n\"\n   128\t            \"   baz\\n\")\n   129\t\n   130\t    app.env.find_files(app.config, app.builder)\n   131\t    doctree = restructuredtext.parse(app, text, 'index')\n   132\t    assert_node(doctree, [nodes.document, nodes.compound, addnodes.toctree])\n   133\t    assert_node(doctree[0][0],\n   134\t                entries=[(None, 'baz'), (None, 'bar/index'), (None, 'foo')],\n   135\t                includefiles=['baz', 'bar/index', 'foo'])\n   136\t\n   137\t\n   138\t@pytest.mark.sphinx(testroot='toctree-glob')\n   139\tdef test_toctree_twice(app):\n   140\t    text = (\".. toctree::\\n\"\n   141\t            \"\\n\"\n   142\t            \"   foo\\n\"\n   143\t            \"   foo\\n\")\n   144\t\n   145\t    app.env.find_files(app.config, app.builder)\n   146\t    doctree = restructuredtext.parse(app, text, 'index')\n   147\t    assert_node(doctree, [nodes.document, nodes.compound, addnodes.toctree])\n   148\t    assert_node(doctree[0][0],\n   149\t                entries=[(None, 'foo'), (None, 'foo')],\n   150\t                includefiles=['foo', 'foo'])\n",
      "perturbed": "1\t\"\"\"Test the other directives.\"\"\"\n3\timport pytest\n2\n4\tfrom docutils import nodes\n5\n6\tfrom sphinx import addnodes\n7\tfrom sphinx.testing import restructuredtext\n9\n11\t@pytest.mark.sphinx(testroot='toctree-glob')\n14\t            \"\\n\"\n13\t    text = (\".. toctree::\\n\"\n15\t            \"   foo\\n\"\n16\t            \"   bar/index\\n\"\n18\n19\t    app.env.find_files(app.config, app.builder)\n20\t    doctree = restructuredtext.parse(app, text, 'index')\n21\t    assert_node(doctree, [nodes.document, nodes.compound, addnodes.toctree])\n24\t                includefiles=['foo', 'bar/index', 'baz'])\n25\n26\n30\t            \"\\n\"\n32\t            \"   bar_2\\n\"\n31\t            \"   bar_1\\n\"\n35\n36\t    app.env.find_files(app.config, app.builder)\n37\t    doctree = restructuredtext.parse(app, text, 'bar/index')\n38\t    assert_node(doctree, [nodes.document, nodes.compound, addnodes.toctree])\n39\t    assert_node(doctree[0][0],\n40\t                entries=[(None, 'bar/bar_1'), (None, 'bar/bar_2'), (None, 'bar/bar_3'),\n42\t                includefiles=['bar/bar_1', 'bar/bar_2', 'bar/bar_3', 'quux'])\n43\n44\n46\tdef test_toctree_urls_and_titles(app):\n47\t    text = (\".. toctree::\\n\"\n48\t            \"\\n\"\n50\t            \"   https://readthedocs.org/\\n\"\n51\t            \"   The BAR <b...\n52\n55\t    assert_node(doctree, [nodes.document, nodes...\n58\t                         (None, 'https://readthedocs.org/'),\n56\t    assert_node(doctree[0][0],\n60\t                includefiles=['bar/index'])\n59\t                         (...\n63\t@pytest.mark.sphinx(testroot='toctree-glob')\n64\tdef test_toctree_glob(app):\n65\t    text = (\".. toctree::\\n\"\n67\t            \"\\n\"\n66\t            \"   :glob:\\n\"\n68\t            \"   *\\n\")\n69\n71\t    doctree = restructuredtext.parse(app, text, 'index')\n73\t    assert_node(doctree[0][0],\n72\t    assert_node(doctree, [nodes.document, nodes.compound, addnodes.toctree])\n76\n79\t            \"   :glob:\\n\"\n83\n84\t    app.env.find_files(app.config, app.builder)\n85\t    doctree = restructuredtext.parse(app, text, 'index')\n87\t    assert_node(doctree[0][0],\n89\t                includefiles=['foo', 'baz', 'quux'])\n88\t                entries=[(None, 'foo'), (None, 'baz'), (None, 'quux')],\n90\n91\t    # give both docname and glob (case2)\n92\t    text = (\".. toctree::\\n\"\n93\t            \"   :glob:\\n\"\n94\t            \"\\n\"\n95\t            \"   *\\n\"\n96\t            \"   foo\\n\")\n100\t    assert_node(doctree, [nodes.document, nodes.compound, addnodes.toctree])\n101\t    assert_node(doctree[0][0],\n103\t                includefiles=['baz', 'foo', 'quux', 'foo'])\n105\n104\n106\t@pytest.mark.sphinx(...\n107\tdef test_toctre...\n108\t    text = (\".. toctree::\\n\"\n110\t            \"\\n\"\n111\t            \"   https://example.com/?q=sphinx\\n\")\n113\t    app.env.find_files(app.config, app.builder)\n112\n114\t    doctree = restructuredtext.parse(app, text, 'index')\n117\t                entries=[(None, 'https://example.com/?q=sphinx')],\n115\t    assert_node(doctree, [nodes.document, nodes.compound, addnodes.toctree])\n118\t                includefiles=[])\n120\n121\t@pytest.mark.sphinx(testroot='toctree-glob')\n122\tdef test_reversed_toctree(app):\n124\t            \"   :reversed:\\n\"\n123\t    text = (\".. toctree::\\n\"\n127\t            \"   bar/index\\n\"\n126\t            \"   foo\\n\"\n128\t            \"   baz\\n\")\n129\n130\t    app.env.find_files(app.config, app.builder)\n131\t    doctree = restructuredtext.parse(app, text, 'index')\n132\t    assert_node(doctree, [nodes.document, nodes.compound, addnodes.toctree])\n134\t                entries=[(None, 'baz'), (None, 'bar/index'), (None, 'foo')],\n133\t    assert_node(doctree[0][0],\n135\t                includefiles=['baz', 'bar/index', 'foo'])\n136\n137\n138\t@pytest.mark.sphinx(testroot='toctree-glob')\n140\t    text = (\".. toctree::\\n\"\n141\t            \"\\n\"\n143\t            \"   foo\\n\")\n142\t            \"   foo\\n\"\n147\t    assert_node(doctree, [nodes.document, nodes.compound, addnodes.toctree])\n146\t    doctree = restructuredtext.parse(app, text, 'index')\n148\t    assert_node(doctree[0][0],\n149\t                entries=[(None, 'foo'), (None, 'foo')],\n150\t                includefiles=['foo', 'foo'])",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "pytest -q -k \"source_read or source-read or include\" || true",
      "original": "..................s.......................................               [100%]\n57 passed, 1 skipped, 1976 deselected in 3.25s\n",
      "perturbed": "..................s.......................................               [100%]",
      "applied_operators": [
        "text_perturbation"
      ]
    }
  ]
}