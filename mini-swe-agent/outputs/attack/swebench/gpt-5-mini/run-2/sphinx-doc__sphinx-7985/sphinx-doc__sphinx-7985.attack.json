{
  "info": {
    "total_observations": 27,
    "python_observations": 0,
    "text_observations": 27,
    "ast_operators_applied": 0,
    "text_perturbation_applied": 21,
    "skipped": 6
  },
  "perturbations": [
    {
      "action": "ls -la",
      "original": "total 484\ndrwxrwxrwx  1 root root   4096 Sep 10 16:05 .\ndrwxr-xr-x  1 root root   4096 Nov 30 01:42 ..\ndrwxr-xr-x  2 root root   4096 Sep 10 16:03 .circleci\n-rw-r--r--  1 root root    129 Sep 10 16:03 .codecov.yml\ndrwxrwxrwx  8 root root   4096 Sep 10 16:05 .git\ndrwxrwxrwx  4 root root   4096 Sep 10 16:03 .github\n-rw-r--r--  1 root root    340 Sep 10 16:03 .gitignore\n-rw-r--r--  1 root root    937 Sep 10 16:03 .travis.yml\n-rw-r--r--  1 root root   4057 Sep 10 16:03 AUTHORS\n-rw-r--r--  1 root root 243535 Sep 10 16:03 CHANGES\n-rw-r--r--  1 root root  42125 Sep 10 16:03 CHANGES.old\n-rw-r--r--  1 root root   3530 Sep 10 16:03 CODE_OF_CONDUCT\n-rw-r--r--  1 root root    581 Sep 10 16:03 CONTRIBUTING.rst\n-rw-r--r--  1 root root  24132 Sep 10 16:03 EXAMPLES\n-rw-r--r--  1 root root   8998 Sep 10 16:03 LICENSE\n-rw-r--r--  1 root root    769 Sep 10 16:03 MANIFEST.in\n-rw-r--r--  1 root root   1810 Sep 10 16:03 Makefile\n-rw-r--r--  1 root root   4552 Sep 10 16:03 README.rst\ndrwxr-xr-x  2 root root   4096 Sep 10 16:05 Sphinx.egg-info\n-rw-r--r--  1 root root    872 Sep 10 16:03 babel.cfg\n-rw-r--r--  1 root root    647 Sep 10 16:03 bindep.txt\ndrwxrwxrwx 10 root root   4096 Sep 10 16:03 doc\n-rw-r--r--  1 root root   1843 Sep 10 16:03 karma.conf.js\n-rw-r--r--  1 root root  45122 Sep 10 16:03 package-lock.json\n-rw-r--r--  1 root root    485 Sep 10 16:03 package.json\n-rw-r--r--  1 root root   1687 Sep 10 16:03 setup.cfg\n-rw-r--r--  1 root root   8488 Sep 10 16:05 setup.py\ndrwxrwxrwx 20 root root   4096 Sep 10 16:05 sphinx\ndrwxrwxrwx  4 root root   4096 Sep 10 16:03 tests\n-rw-r--r--  1 root root   2023 Sep 10 16:05 tox.ini\ndrwxrwxrwx  2 root root   4096 Sep 10 16:03 utils\n",
      "perturbed": "total 484\ndrwxrwxrwx  1 root root   4096 Sep 10 16:05 .\ndrwxr-xr-x  1 root root   4096 Nov 30 01:42 ..\ndrwxrwxrwx  8 root root   4096 Sep 10 16:05 .git\ndrwxrwxrwx  4 root root   4096 Sep 10 16:03 .github\n-rw-r--r--  1 root root    937 Sep 10 16:03 .travis.yml\n-rw-r--r--  1 root root    340 Sep 10 16:03 .gitignore\n-rw-r--r--  1 root root   4057 Sep 10 16:03 AUTHORS\n-rw-r--r--  1 root root 243535 Sep 10 16:03 CHANGES\n-rw-r--r--  1 root root  42125 Sep 10 16:03 CHANGES.old\n-rw-r--r--  1 root root   3530 Sep 10 16:03 CODE_OF_CONDUCT\n-rw-r--r--  1 root root  24132 Sep 10 16:03 EXAMPLES\n-rw-r--r--  1 root root    769 Sep 10 16:03 MANIFEST.in\ndrwxr-xr-x  2 root root   4096 Sep 10 1...\n-rw-r--r--  1 root root   1810 Sep 10 16:03 Makefile\n-rw-r--r--  1 root root    647 Sep 10 16:03 bindep.txt\n-rw-r--r--  1 root root   1843 Sep 10 16:03 karma.conf.js\n-rw-r--r--  1 root root   1687 Sep 10 16:03 setup.cfg\n-rw-r--r--  1 root root   84...\ndrwxrwxrwx 20 root root   4096 Sep 10 16:05 sphinx\n-rw-r--r--  1 root root   2023 Sep 10 16:05 tox.ini\ndrwxrwxrwx  2 root root   4096 Sep 10 16:03 utils",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "ls -la testbed",
      "original": "ls: cannot access 'testbed': No such file or directory\n",
      "perturbed": "ls: cannot access 'testbed': No such file or directory",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "grep -RIn \"linkcheck\" -n sphinx || true",
      "original": "sphinx/locale/ur/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/ur/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/ur/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/ur/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/sr/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/sr/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/sr/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/sr/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/eo/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/eo/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/eo/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/eo/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/eu/LC_MESSAGES/sphinx.po:761:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/eu/LC_MESSAGES/sphinx.po:766:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/eu/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/eu/LC_MESSAGES/sphinx.po:1584:\"linkcheck.\"\nsphinx/locale/sv/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/sv/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/sv/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/sv/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/he/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/he/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/he/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/he/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/lt/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/lt/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/lt/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/lt/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/sphinx.pot:765:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/sphinx.pot:770:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/sphinx.pot:775:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/sphinx.pot:1598:\"linkcheck.\"\nsphinx/locale/et/LC_MESSAGES/sphinx.po:763:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/et/LC_MESSAGES/sphinx.po:768:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/et/LC_MESSAGES/sphinx.po:773:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/et/LC_MESSAGES/sphinx.po:1586:\"linkcheck.\"\nsphinx/locale/pt/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/pt/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/pt/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/pt/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/te/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/te/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/te/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/te/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/hu/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/hu/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/hu/LC_MESSAGES/sphinx.po:774:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/hu/LC_MESSAGES/sphinx.po:1587:\"linkcheck.\"\nsphinx/locale/cak/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/cak/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/cak/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/cak/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/uk_UA/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/uk_UA/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/uk_UA/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/uk_UA/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/sk/LC_MESSAGES/sphinx.po:762:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/sk/LC_MESSAGES/sphinx.po:767:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/sk/LC_MESSAGES/sphinx.po:772:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/sk/LC_MESSAGES/sphinx.po:1585:\"linkcheck.\"\nsphinx/locale/fa/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/fa/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/fa/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/fa/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/es/LC_MESSAGES/sphinx.po:766:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/es/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/es/LC_MESSAGES/sphinx.po:776:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/es/LC_MESSAGES/sphinx.po:1589:\"linkcheck.\"\nsphinx/locale/es/LC_MESSAGES/sphinx.po:1590:msgstr \"donde \\\"builder\\\" es uno de los constructores compatibles, por ejemplo, html, latex o linkcheck.\"\nsphinx/locale/pl/LC_MESSAGES/sphinx.po:763:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/pl/LC_MESSAGES/sphinx.po:768:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/pl/LC_MESSAGES/sphinx.po:773:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/pl/LC_MESSAGES/sphinx.po:1586:\"linkcheck.\"\nsphinx/locale/ne/LC_MESSAGES/sphinx.po:761:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/ne/LC_MESSAGES/sphinx.po:766:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/ne/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/ne/LC_MESSAGES/sphinx.po:1584:\"linkcheck.\"\nsphinx/locale/el/LC_MESSAGES/sphinx.po:761:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/el/LC_MESSAGES/sphinx.po:766:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/el/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/el/LC_MESSAGES/sphinx.po:1584:\"linkcheck.\"\nsphinx/locale/de/LC_MESSAGES/sphinx.po:763:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/de/LC_MESSAGES/sphinx.po:768:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/de/LC_MESSAGES/sphinx.po:773:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/de/LC_MESSAGES/sphinx.po:1586:\"linkcheck.\"\nsphinx/locale/da/LC_MESSAGES/sphinx.po:762:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/da/LC_MESSAGES/sphinx.po:767:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/da/LC_MESSAGES/sphinx.po:772:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/da/LC_MESSAGES/sphinx.po:1585:\"linkcheck.\"\nsphinx/locale/nb_NO/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/nb_NO/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/nb_NO/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/nb_NO/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/ta/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/ta/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/ta/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/ta/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/vi/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/vi/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/vi/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/vi/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/sl/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/sl/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/sl/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/sl/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/bg/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/bg/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/bg/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/bg/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/zh_TW/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/zh_TW/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/zh_TW/LC_MESSAGES/sphinx.po:775:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/zh_TW/LC_MESSAGES/sphinx.po:1588:\"linkcheck.\"\nsphinx/locale/id/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/id/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/id/LC_MESSAGES/sphinx.po:774:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/id/LC_MESSAGES/sphinx.po:1587:\"linkcheck.\"\nsphinx/locale/hi_IN/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/hi_IN/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/hi_IN/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/hi_IN/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/tr/LC_MESSAGES/sphinx.po:762:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/tr/LC_MESSAGES/sphinx.po:767:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/tr/LC_MESSAGES/sphinx.po:772:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/tr/LC_MESSAGES/sphinx.po:1585:\"linkcheck.\"\nsphinx/locale/tr/LC_MESSAGES/sphinx.po:1586:msgstr \"\\\"builder\\\" burada desteklenen olu\u015fturuculardan biridir, \u00f6rn. html, latex veya linkcheck.\"\nsphinx/locale/ru/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/ru/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/ru/LC_MESSAGES/sphinx.po:775:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/ru/LC_MESSAGES/sphinx.po:1588:\"linkcheck.\"\nsphinx/locale/it/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/it/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/it/LC_MESSAGES/sphinx.po:774:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/it/LC_MESSAGES/sphinx.po:1587:\"linkcheck.\"\nsphinx/locale/ro/LC_MESSAGES/sphinx.po:761:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/ro/LC_MESSAGES/sphinx.po:766:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/ro/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/ro/LC_MESSAGES/sphinx.po:1584:\"linkcheck.\"\nsphinx/locale/ja/LC_MESSAGES/sphinx.po:774:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/ja/LC_MESSAGES/sphinx.po:779:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/ja/LC_MESSAGES/sphinx.po:784:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/ja/LC_MESSAGES/sphinx.po:1597:\"linkcheck.\"\nsphinx/locale/ja/LC_MESSAGES/sphinx.po:1598:msgstr \"\\\"builder\\\" \u306f\u30b5\u30dd\u30fc\u30c8\u3055\u308c\u3066\u3044\u308b\u30d3\u30eb\u30c0\u30fc\u306e 1 \u3064\u3067\u3059\u3002 \u4f8b: html, latex, \u307e\u305f\u306f linkcheck\u3002\"\nsphinx/locale/ar/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/ar/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/ar/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/ar/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/nl/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/nl/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/nl/LC_MESSAGES/sphinx.po:775:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/nl/LC_MESSAGES/sphinx.po:1588:\"linkcheck.\"\nsphinx/locale/ca/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/ca/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/ca/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/ca/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/hr/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/hr/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/hr/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/hr/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/cy/LC_MESSAGES/sphinx.po:761:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/cy/LC_MESSAGES/sphinx.po:766:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/cy/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/cy/LC_MESSAGES/sphinx.po:1584:\"linkcheck.\"\nsphinx/locale/mk/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/mk/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/mk/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/mk/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/si/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/si/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/si/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/si/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/fi/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/fi/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/fi/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/fi/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/bn/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/bn/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/bn/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/bn/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/sr@latin/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/sr@latin/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/sr@latin/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/sr@latin/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/zh_CN/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/zh_CN/LC_MESSAGES/sphinx.po:776:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/zh_CN/LC_MESSAGES/sphinx.po:781:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/zh_CN/LC_MESSAGES/sphinx.po:1594:\"linkcheck.\"\nsphinx/locale/hi/LC_MESSAGES/sphinx.po:763:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/hi/LC_MESSAGES/sphinx.po:768:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/hi/LC_MESSAGES/sphinx.po:773:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/hi/LC_MESSAGES/sphinx.po:1586:\"linkcheck.\"\nsphinx/locale/fr/LC_MESSAGES/sphinx.po:780:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/fr/LC_MESSAGES/sphinx.po:785:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/fr/LC_MESSAGES/sphinx.po:790:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/fr/LC_MESSAGES/sphinx.po:1603:\"linkcheck.\"\nsphinx/locale/cs/LC_MESSAGES/sphinx.po:761:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/cs/LC_MESSAGES/sphinx.po:766:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/cs/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/cs/LC_MESSAGES/sphinx.po:1584:\"linkcheck.\"\nsphinx/locale/sr_RS/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/sr_RS/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/sr_RS/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/sr_RS/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/pt_BR/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/pt_BR/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/pt_BR/LC_MESSAGES/sphinx.po:775:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/pt_BR/LC_MESSAGES/sphinx.po:1588:\"linkcheck.\"\nsphinx/locale/pt_BR/LC_MESSAGES/sphinx.po:1589:msgstr \"sendo \u201ccompilador\u201d um dos compiladores com suporte, p.ex., html, latex ou linkcheck.\"\nsphinx/locale/pt_PT/LC_MESSAGES/sphinx.po:761:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/pt_PT/LC_MESSAGES/sphinx.po:766:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/pt_PT/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/pt_PT/LC_MESSAGES/sphinx.po:1584:\"linkcheck.\"\nsphinx/locale/lv/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/lv/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/lv/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/lv/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/sq/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/sq/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/sq/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/sq/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/sq/LC_MESSAGES/sphinx.po:1583:msgstr \"ku montues \u00ebsht\u00eb nj\u00eb nga montuesin e mbuluar, p.sh., html, latex ose linkcheck.\"\nsphinx/locale/ko/LC_MESSAGES/sphinx.po:761:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/ko/LC_MESSAGES/sphinx.po:766:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/ko/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/ko/LC_MESSAGES/sphinx.po:1584:\"linkcheck.\"\nsphinx/builders/linkcheck.py:2:    sphinx.builders.linkcheck\nsphinx/builders/linkcheck.py:82:    name = 'linkcheck'\nsphinx/builders/linkcheck.py:87:        self.to_ignore = [re.compile(x) for x in self.app.config.linkcheck_ignore]\nsphinx/builders/linkcheck.py:89:                               for x in self.app.config.linkcheck_anchors_ignore]\nsphinx/builders/linkcheck.py:91:                     in self.app.config.linkcheck_auth]\nsphinx/builders/linkcheck.py:106:        for i in range(self.app.config.linkcheck_workers):\nsphinx/builders/linkcheck.py:116:        if self.app.config.linkcheck_timeout:\nsphinx/builders/linkcheck.py:117:            kwargs['timeout'] = self.app.config.linkcheck_timeout\nsphinx/builders/linkcheck.py:127:                if u in self.config.linkcheck_request_headers:\nsphinx/builders/linkcheck.py:129:                    headers.update(self.config.linkcheck_request_headers[u])\nsphinx/builders/linkcheck.py:163:                if anchor and self.app.config.linkcheck_anchors:\nsphinx/builders/linkcheck.py:228:            for _ in range(self.app.config.linkcheck_retries):\nsphinx/builders/linkcheck.py:358:    app.add_config_value('linkcheck_ignore', [], None)\nsphinx/builders/linkcheck.py:359:    app.add_config_value('linkcheck_auth', [], None)\nsphinx/builders/linkcheck.py:360:    app.add_config_value('linkcheck_request_headers', {}, None)\nsphinx/builders/linkcheck.py:361:    app.add_config_value('linkcheck_retries', 1, None)\nsphinx/builders/linkcheck.py:362:    app.add_config_value('linkcheck_timeout', None, None, [int])\nsphinx/builders/linkcheck.py:363:    app.add_config_value('linkcheck_workers', 5, None)\nsphinx/builders/linkcheck.py:364:    app.add_config_value('linkcheck_anchors', True, None)\nsphinx/builders/linkcheck.py:367:    app.add_config_value('linkcheck_anchors_ignore', [\"^!\"], None)\nsphinx/cmd/quickstart.py:435:             'e.g. html, latex or linkcheck.'))\nsphinx/cmd/make_mode.py:50:    (\"\",      \"linkcheck\",   \"to check all external links for integrity\"),\nsphinx/application.py:72:    'sphinx.builders.linkcheck',\nsphinx/templates/quickstart/Makefile_t:45:\t@echo \"  linkcheck   to check all external links for integrity\"\nsphinx/templates/quickstart/make.bat_t:42:\techo.  linkcheck  to check all external links for integrity\n",
      "perturbed": "sphinx/locale/ur/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/ur/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/li...\nsphinx/locale/sr/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/ur/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/sr/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkchec...\nsphinx/locale/sr/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/eo/LC_MESSAGES/sphinx.po:7...\nsphinx/locale/eo/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/eo/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/eu/LC_MESSAGES/sphinx.po:761:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/eu/LC_MESSAGES/sphinx.po:766:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/sv/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck....\n[info] processing...\nsphinx/locale/eu/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/sv/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/sv/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/he/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/he/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/he/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/lt/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/lt/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/lt/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/sphinx.pot:775:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/sphinx.pot:770:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/sphinx.pot:1598:\"linkcheck.\"\nsphinx/locale/et/LC_MESSAGES/sphinx.po:768:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/et/LC_MESSAGES/sphinx.po:763:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/et/LC_MESSAGES/sphinx.po:1586:\"linkcheck.\"\nsphinx/locale/pt/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/pt/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/pt/LC_MES...\nsphinx/locale/te/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/te/LC_MESSAGES/sphinx.po:764:#: ...\nsphinx/locale/hu/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/te/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/hu/LC_MESSAGES/sphinx.po:774:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/cak/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/cak/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/cak/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/uk_UA/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/uk_UA/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/uk_UA/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/uk_UA/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/sk/LC_MESSAGES/sphinx.po:762:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/sk/LC_MESSAGES/sphinx.po:767:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/sk/LC_MESSAGES/sphinx.po:1585:\"linkcheck.\"\nsphinx/locale/fa/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/fa/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/fa/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/fa/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/es/LC_MESSAGES/sphinx.po:766:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/es/LC_MESSAGES/sphinx.po:1589:\"linkcheck.\"\nsphinx/locale/es/LC_MESSAGES/sphinx.po:776:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/pl/LC_MESSAGES/sphinx.po:763:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/pl/LC_MESSAGES/sphinx.po:1586:\"linkcheck.\"\nsphinx/locale/ne/LC_MESSAGES/sphinx.po:766:#: sphinx...\nsphinx/locale/ne/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/ne/LC_MESSAGES/sphinx.po:1584:\"linkcheck.\"\nsphinx/locale/el/LC_MESSAGES/sphinx.po:761:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/el/LC_MESSAGES/sphinx.po:766:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/el/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/de/LC_MESSAGES/sphinx.po:768:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/da/LC_MESSAGES/sphinx.po:762:#: sphinx/bui...\nsphinx/locale/de/LC_MESSAGES/sphinx.po:773:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/da/LC_MESSAGES/sphinx.po:767:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/da/LC_MESSAGES/sphinx.po:1585:\"linkc...\nsphinx/locale/nb_NO/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/nb_NO/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/nb_NO/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/nb_NO/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/ta/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/ta/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/ta/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/ta/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/vi/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/sl/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/link...\nsphinx/locale/vi/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/sl/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/sl/LC_MESSAGES/sphinx.po:769:#: sphi...\nsphinx/locale/bg/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/sl/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/bg/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/bg/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/bg/LC_MESSAGES/sphinx.po:769:#: sphinx/builder...\nsphinx/locale/zh_TW/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/zh_TW/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/id/LC_MESSAGES/sphinx.po:764:#: sphinx/builders...\nsphinx/locale/zh_TW/LC_MESSAGES/sphinx.po:775:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/id/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/id/LC_MESSAGES/sphinx.po:774:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/hi_IN/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/hi_IN/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/tr/LC_MESSAGES/sphinx.po:762:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/tr/LC_MESSAGES/sphinx.po:767:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/tr/LC_MESSAGES/sphinx.po:1585:\"linkcheck.\"\nsphinx/locale/tr/LC_MESSAGES/sphinx.po:772:#: s...\nsphinx/locale/ru/LC_MESSAGES/sphinx.po:775:#: sphinx/builders/l...\nsphinx/locale/ru/LC_MESSAGES/sphinx.po:1588:\"linkcheck.\"\nsphinx/locale/it/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/it/LC_MESSAGES/sphinx.po:774:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/it/LC_MESSAGES/sphinx.po:1587:\"linkcheck.\"\nsphinx/locale/ro/LC_MESSAGES/sphinx.po:761:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/ro/LC_MESSAGES/sphinx.po:766:#: sphinx/builder...\nsphinx/locale/ro/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/ja/LC_MESSAGES/sphinx.po:779:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/ja/LC_MESSAGES/sphinx.po:784:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/ja/LC_MESSAGES/sphinx.po:1598:msgstr \"\\\"builder\\\" \u306f\u30b5\u30dd\u30fc\u30c8\u3055\u308c\u3066\u3044\u308b\u30d3\u30eb\u30c0\u30fc\u306e 1 \u3064\u3067\u3059\u3002 \u4f8b: html, latex, \u307e\u305f\u306f linkcheck\u3002\"\nsphinx/locale/ar/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/ar/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/ar/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/ar/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/nl/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/nl/LC_MESSAGES/sphinx.po:775:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/ca/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/nl/LC_MESSAGES/sphinx.po:1588:\"linkcheck.\"\nsphinx/locale/ca/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/ca/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/cy/LC_MESSAGES/sphinx.po:766:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/hr/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/cy/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/cy/LC_MESSAGES/sphinx.po:1584:\"linkcheck.\"\nsphinx/locale/mk/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.p...\nsphinx/locale/mk/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/si/LC_MESSAGES/sphinx.po:760:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/si/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/si/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/si/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/bn/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/fi/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/bn/LC_MESSAGES/sphinx.po:1583:\"linkcheck.\"\nsphinx/locale/sr@latin/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/sr@latin/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/sr@latin/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/sr@latin/LC_MESSAGE...\nsphinx/locale/zh_CN/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/zh_CN/LC_MESSAGES/sphinx.po:776:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/zh_CN/LC_MESSAGES/sphinx.po:1594:\"linkcheck.\"\nsphinx/locale/zh_CN/LC_MESSAGES/sphinx.po:781:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/hi/LC_MESSAGES/sphinx.po:763:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/hi/LC_MESSAGES/sphinx.po:...\nsphinx/locale/hi/LC_MESSAGES/sphinx.po:773:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/fr/LC_MESSAGES/sphinx.po:785:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/fr/LC_MESSAGES/sphinx.po:780:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/fr/LC_MESSAGES/sphinx.po:1603:\"linkcheck.\"\nsphinx/locale/cs/LC_MESSAGES/sphinx.po:761:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/cs/LC_MESSAGES/sphinx.po:766:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/cs/LC_MESSAGES/sphinx.po:1584:\"linkcheck.\"\nsphinx/locale/cs/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/sr_RS/LC_MESSAGES/sphinx.po:764:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/sr_RS/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/pt_BR/LC_MESSAGES/sphinx.po:765:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/sr_RS/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/pt_BR/LC_MESSAGES/sphinx.po:770:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/pt_BR/LC_MESSAGES/sphinx.po:775:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/pt_BR/LC_MESSAGES/sphinx.po:1588:\"linkcheck.\"\nsphinx/locale/pt_PT/LC_MESSAGES/sphinx.po:766:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/pt_PT/LC_MESSAGES/sphinx.po:761:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/pt_PT/LC_MESSAGES/sphinx.po:1584:\"linkcheck.\"\nsphinx/locale/lv/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/lv/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/lv/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/sq/LC_MESSAGES/sphinx.po:759:#: sphinx/builders/linkcheck.py:78\nsphinx/locale/sq/LC_MESSAGES/sphinx.po:769:#: sphinx/builders/linkcheck.py:259\nsphinx/locale/sq/LC_MESSAGES/sphinx.po:1582:\"linkcheck.\"\nsphinx/locale/sq/LC_MESSAGES/sphinx.po:1583:msgstr \"ku montues \u00ebsht\u00eb nj\u00eb nga montuesin e mbuluar, p.sh., html, latex ose linkcheck.\"\nsphinx/locale/ko/LC_MESSA...\nsphinx/locale/ko/LC_MESSAGES/sphinx.po:766:#: sphinx/builders/linkcheck.py:150\nsphinx/locale/ko/LC_MESSAGES/sphinx.po:1584:\"linkcheck.\"\nsphinx/locale/ko/LC_MESSAGES/sphinx.po:771:#: sphinx/builders/linkcheck.py:259\nsphinx/builders/linkcheck.py:2:    sphinx.builders.linkcheck\nsphinx/builders/linkcheck.py:89:                               for x in self.app.config.linkcheck_anchors_ignore]\nsphinx/builders/linkcheck.py:117:            kwargs['timeout'] = self.app.config.linkcheck_timeout\nsphinx/builders/linkcheck.py:91:                     in sel...\nsphinx/builders/linkcheck.py:127:                if u in self.config.linkcheck_request_headers:\nsphinx/builders/linkcheck.py:163:                if anchor and self.app.config.linkcheck_anchors:\nsphinx/builders/linkcheck.py:228:            for _ in range(self.app.config.linkcheck_retries):\nsphinx/builders/linkcheck.py:361:    app.add_config_value('linkcheck_retries', 1,...\nsphinx/builders/linkcheck.py:359:    app.add_config_value('linkcheck_auth', [], None)\nsphinx/builders/linkcheck.py:363:    app.add_config_value('linkcheck_workers', 5, None)\nsphinx/builders/linkcheck.py:364:    app.add_config_value('linkcheck_anchors', True, None)\nsphinx/application.py:72:    'sphinx.builders.linkcheck',\nsphinx/cmd/quickstart....\nsphinx/templates/quickstart/Makefile_t:45:\t@echo \"  linkcheck   to check all external links for integrity\"\nsphinx/templates/quickstart/make.bat_t:42:\techo.  linkcheck  to check all external links for integrity",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba sphinx/builders/linkcheck.py | sed -n '1,260p'",
      "original": "     1\t\"\"\"\n     2\t    sphinx.builders.linkcheck\n     3\t    ~~~~~~~~~~~~~~~~~~~~~~~~~\n     4\t\n     5\t    The CheckExternalLinksBuilder class.\n     6\t\n     7\t    :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n     8\t    :license: BSD, see LICENSE for details.\n     9\t\"\"\"\n    10\t\n    11\timport json\n    12\timport queue\n    13\timport re\n    14\timport socket\n    15\timport threading\n    16\tfrom html.parser import HTMLParser\n    17\tfrom os import path\n    18\tfrom typing import Any, Dict, List, Set, Tuple\n    19\tfrom urllib.parse import unquote, urlparse\n    20\t\n    21\tfrom docutils import nodes\n    22\tfrom docutils.nodes import Node\n    23\tfrom requests.exceptions import HTTPError\n    24\t\n    25\tfrom sphinx.application import Sphinx\n    26\tfrom sphinx.builders import Builder\n    27\tfrom sphinx.locale import __\n    28\tfrom sphinx.util import encode_uri, requests, logging\n    29\tfrom sphinx.util.console import (  # type: ignore\n    30\t    purple, red, darkgreen, darkgray, turquoise\n    31\t)\n    32\tfrom sphinx.util.nodes import get_node_line\n    33\tfrom sphinx.util.requests import is_ssl_error\n    34\t\n    35\t\n    36\tlogger = logging.getLogger(__name__)\n    37\t\n    38\t\n    39\tDEFAULT_REQUEST_HEADERS = {\n    40\t    'Accept': 'text/html,application/xhtml+xml;q=0.9,*/*;q=0.8',\n    41\t}\n    42\t\n    43\t\n    44\tclass AnchorCheckParser(HTMLParser):\n    45\t    \"\"\"Specialized HTML parser that looks for a specific anchor.\"\"\"\n    46\t\n    47\t    def __init__(self, search_anchor: str) -> None:\n    48\t        super().__init__()\n    49\t\n    50\t        self.search_anchor = search_anchor\n    51\t        self.found = False\n    52\t\n    53\t    def handle_starttag(self, tag: Any, attrs: Any) -> None:\n    54\t        for key, value in attrs:\n    55\t            if key in ('id', 'name') and value == self.search_anchor:\n    56\t                self.found = True\n    57\t                break\n    58\t\n    59\t\n    60\tdef check_anchor(response: requests.requests.Response, anchor: str) -> bool:\n    61\t    \"\"\"Reads HTML data from a response object `response` searching for `anchor`.\n    62\t    Returns True if anchor was found, False otherwise.\n    63\t    \"\"\"\n    64\t    parser = AnchorCheckParser(anchor)\n    65\t    # Read file in chunks. If we find a matching anchor, we break\n    66\t    # the loop early in hopes not to have to download the whole thing.\n    67\t    for chunk in response.iter_content(chunk_size=4096, decode_unicode=True):\n    68\t        if isinstance(chunk, bytes):    # requests failed to decode\n    69\t            chunk = chunk.decode()      # manually try to decode it\n    70\t\n    71\t        parser.feed(chunk)\n    72\t        if parser.found:\n    73\t            break\n    74\t    parser.close()\n    75\t    return parser.found\n    76\t\n    77\t\n    78\tclass CheckExternalLinksBuilder(Builder):\n    79\t    \"\"\"\n    80\t    Checks for broken external links.\n    81\t    \"\"\"\n    82\t    name = 'linkcheck'\n    83\t    epilog = __('Look for any errors in the above output or in '\n    84\t                '%(outdir)s/output.txt')\n    85\t\n    86\t    def init(self) -> None:\n    87\t        self.to_ignore = [re.compile(x) for x in self.app.config.linkcheck_ignore]\n    88\t        self.anchors_ignore = [re.compile(x)\n    89\t                               for x in self.app.config.linkcheck_anchors_ignore]\n    90\t        self.auth = [(re.compile(pattern), auth_info) for pattern, auth_info\n    91\t                     in self.app.config.linkcheck_auth]\n    92\t        self.good = set()       # type: Set[str]\n    93\t        self.broken = {}        # type: Dict[str, str]\n    94\t        self.redirected = {}    # type: Dict[str, Tuple[str, int]]\n    95\t        # set a timeout for non-responding servers\n    96\t        socket.setdefaulttimeout(5.0)\n    97\t        # create output file\n    98\t        open(path.join(self.outdir, 'output.txt'), 'w').close()\n    99\t        # create JSON output file\n   100\t        open(path.join(self.outdir, 'output.json'), 'w').close()\n   101\t\n   102\t        # create queues and worker threads\n   103\t        self.wqueue = queue.Queue()  # type: queue.Queue\n   104\t        self.rqueue = queue.Queue()  # type: queue.Queue\n   105\t        self.workers = []  # type: List[threading.Thread]\n   106\t        for i in range(self.app.config.linkcheck_workers):\n   107\t            thread = threading.Thread(target=self.check_thread)\n   108\t            thread.setDaemon(True)\n   109\t            thread.start()\n   110\t            self.workers.append(thread)\n   111\t\n   112\t    def check_thread(self) -> None:\n   113\t        kwargs = {\n   114\t            'allow_redirects': True,\n   115\t        }  # type: Dict\n   116\t        if self.app.config.linkcheck_timeout:\n   117\t            kwargs['timeout'] = self.app.config.linkcheck_timeout\n   118\t\n   119\t        def get_request_headers() -> Dict:\n   120\t            url = urlparse(uri)\n   121\t            candidates = [\"%s://%s\" % (url.scheme, url.netloc),\n   122\t                          \"%s://%s/\" % (url.scheme, url.netloc),\n   123\t                          uri,\n   124\t                          \"*\"]\n   125\t\n   126\t            for u in candidates:\n   127\t                if u in self.config.linkcheck_request_headers:\n   128\t                    headers = dict(DEFAULT_REQUEST_HEADERS)\n   129\t                    headers.update(self.config.linkcheck_request_headers[u])\n   130\t                    return headers\n   131\t\n   132\t            return {}\n   133\t\n   134\t        def check_uri() -> Tuple[str, str, int]:\n   135\t            # split off anchor\n   136\t            if '#' in uri:\n   137\t                req_url, anchor = uri.split('#', 1)\n   138\t                for rex in self.anchors_ignore:\n   139\t                    if rex.match(anchor):\n   140\t                        anchor = None\n   141\t                        break\n   142\t            else:\n   143\t                req_url = uri\n   144\t                anchor = None\n   145\t\n   146\t            # handle non-ASCII URIs\n   147\t            try:\n   148\t                req_url.encode('ascii')\n   149\t            except UnicodeError:\n   150\t                req_url = encode_uri(req_url)\n   151\t\n   152\t            # Get auth info, if any\n   153\t            for pattern, auth_info in self.auth:\n   154\t                if pattern.match(uri):\n   155\t                    break\n   156\t            else:\n   157\t                auth_info = None\n   158\t\n   159\t            # update request headers for the URL\n   160\t            kwargs['headers'] = get_request_headers()\n   161\t\n   162\t            try:\n   163\t                if anchor and self.app.config.linkcheck_anchors:\n   164\t                    # Read the whole document and see if #anchor exists\n   165\t                    response = requests.get(req_url, stream=True, config=self.app.config,\n   166\t                                            auth=auth_info, **kwargs)\n   167\t                    found = check_anchor(response, unquote(anchor))\n   168\t\n   169\t                    if not found:\n   170\t                        raise Exception(__(\"Anchor '%s' not found\") % anchor)\n   171\t                else:\n   172\t                    try:\n   173\t                        # try a HEAD request first, which should be easier on\n   174\t                        # the server and the network\n   175\t                        response = requests.head(req_url, config=self.app.config,\n   176\t                                                 auth=auth_info, **kwargs)\n   177\t                        response.raise_for_status()\n   178\t                    except HTTPError:\n   179\t                        # retry with GET request if that fails, some servers\n   180\t                        # don't like HEAD requests.\n   181\t                        response = requests.get(req_url, stream=True, config=self.app.config,\n   182\t                                                auth=auth_info, **kwargs)\n   183\t                        response.raise_for_status()\n   184\t            except HTTPError as err:\n   185\t                if err.response.status_code == 401:\n   186\t                    # We'll take \"Unauthorized\" as working.\n   187\t                    return 'working', ' - unauthorized', 0\n   188\t                elif err.response.status_code == 503:\n   189\t                    # We'll take \"Service Unavailable\" as ignored.\n   190\t                    return 'ignored', str(err), 0\n   191\t                else:\n   192\t                    return 'broken', str(err), 0\n   193\t            except Exception as err:\n   194\t                if is_ssl_error(err):\n   195\t                    return 'ignored', str(err), 0\n   196\t                else:\n   197\t                    return 'broken', str(err), 0\n   198\t            if response.url.rstrip('/') == req_url.rstrip('/'):\n   199\t                return 'working', '', 0\n   200\t            else:\n   201\t                new_url = response.url\n   202\t                if anchor:\n   203\t                    new_url += '#' + anchor\n   204\t                # history contains any redirects, get last\n   205\t                if response.history:\n   206\t                    code = response.history[-1].status_code\n   207\t                    return 'redirected', new_url, code\n   208\t                else:\n   209\t                    return 'redirected', new_url, 0\n   210\t\n   211\t        def check() -> Tuple[str, str, int]:\n   212\t            # check for various conditions without bothering the network\n   213\t            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n   214\t                return 'unchecked', '', 0\n   215\t            elif not uri.startswith(('http:', 'https:')):\n   216\t                return 'local', '', 0\n   217\t            elif uri in self.good:\n   218\t                return 'working', 'old', 0\n   219\t            elif uri in self.broken:\n   220\t                return 'broken', self.broken[uri], 0\n   221\t            elif uri in self.redirected:\n   222\t                return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n   223\t            for rex in self.to_ignore:\n   224\t                if rex.match(uri):\n   225\t                    return 'ignored', '', 0\n   226\t\n   227\t            # need to actually check the URI\n   228\t            for _ in range(self.app.config.linkcheck_retries):\n   229\t                status, info, code = check_uri()\n   230\t                if status != \"broken\":\n   231\t                    break\n   232\t\n   233\t            if status == \"working\":\n   234\t                self.good.add(uri)\n   235\t            elif status == \"broken\":\n   236\t                self.broken[uri] = info\n   237\t            elif status == \"redirected\":\n   238\t                self.redirected[uri] = (info, code)\n   239\t\n   240\t            return (status, info, code)\n   241\t\n   242\t        while True:\n   243\t            uri, docname, lineno = self.wqueue.get()\n   244\t            if uri is None:\n   245\t                break\n   246\t            status, info, code = check()\n   247\t            self.rqueue.put((uri, docname, lineno, status, info, code))\n   248\t\n   249\t    def process_result(self, result: Tuple[str, str, int, str, str, int]) -> None:\n   250\t        uri, docname, lineno, status, info, code = result\n   251\t\n   252\t        filename = self.env.doc2path(docname, None)\n   253\t        linkstat = dict(filename=filename, lineno=lineno,\n   254\t                        status=status, code=code, uri=uri,\n   255\t                        info=info)\n   256\t        if status == 'unchecked':\n   257\t            self.write_linkstat(linkstat)\n   258\t            return\n   259\t        if status == 'working' and info == 'old':\n   260\t            self.write_linkstat(linkstat)\n",
      "perturbed": "1\t\"\"\"\n2\t    sphinx.builders.linkcheck\n3\t    ~~~~~~~~~~~~~~~~~~~~~~~~~\n4\n5\t    The CheckExternalLinksBuilder class.\n7\t    :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n9\t\"\"\"\n11\timport json\n13\timport re\n12\timport queue\n14\timport socket\n15\timport threading\n16\tfrom html.parser import HTMLParser\n17\tfrom os import path\n18\tfrom typing import Any, Dict, List, Set, Tuple\n19\tfrom urllib.parse import unquote, urlparse\n21\tfrom docutils import nodes\n22\tfrom docutils.nodes import Node\n24\n26\tfrom sphinx.builders import Builder\n25\tfrom sphinx.application import Sphinx\n29\tfrom sphinx.util.console import (  # type: ignore\n27\tfrom sphinx.locale import __\n30\t    purple, red, darkgreen, darkgray, turquoise\n31\t)\n32\tfrom sphinx.util.nodes import get_node_line\n33\tfrom sphinx.util.requests import is_ssl_error\n34\n36\tlogger = logging.getLogger(__name__)\n37\n39\tDEFAULT_REQUEST_HEADERS = {\n38\n42\n41\t}\n44\tclass AnchorChec...\n46\n47\t    def __init__(self, search_anchor: str) -> None:\n49\n50\t        self.search_anchor = search_anchor\n53\t    def handle_starttag(self, tag: Any, attrs: Any) -> None:\n51\t        self.found = False\n54\t        for key, value in attrs:\n55\t            if key in ('id', 'name') and value == self.search_anchor:\n56\t                self.found = True\n57\t                break\n58\n61\t    \"\"\"Reads HTML data from a response object `response` searching for `anchor`.\n62\t    Returns True if anchor was found, False otherwise.\n64\t    parser = AnchorCheckParser(anchor)\n63\t    \"\"\"\n65\t    # Read file in chunks. If we find a matching anchor, we break\n67\t    for chunk in response.iter_content(chunk_size=4096, decode_unicode=True):\n66\t    # the loop early in hopes not to have to download the whole thing.\n70\n71\t        parser.feed(chunk)\n72\t        if parser.found:\n73\t            break\n74\t    parser.close()\n75\t    return parser.found\n77\n79\t    \"\"\"\n80\t    Checks for broken external links.\n81\t    \"\"\"\n82\t    name = 'linkcheck'\n87\t        self.to_ignore = [re.compile(x) for x in self.app.config.linkcheck_ignore]\n85\n89\t                               for x in self.app.config.linkcheck_anchors_ignore]\n88\t        self.anchors_ignore = [re.compile(x)\n90\t        self.auth = ...\n91\t                     in self.app.config.linkcheck_auth]\n92\t        self.good = set()  ...\n93\t        self.broken = {}    ...\n94\t        self.redirected = ...\n95\t        # set a timeout for non-responding servers\n96\t        socket.setdefaulttimeout(5.0)\n97\t        # create output file\n98\t        open(path.join(self.outdir, 'output.txt'), 'w').close()\n99\t        # create JSON output file\n100\t        open(path.join(self.outdir, 'outpu...\n101\n102\t        # create queues and worke...\n105\t        self.workers = []  # type: List[threading.Thread]\n104\t        self.rqueue = queue.Queue()  ...\n106\t        for i in range(self.app.config.linkcheck_workers):\n108\t            thread.setDaemon(True)\n107\t            thread =...\n109\t            thread.start()\n110\t            self.workers.append(thread)\n111\n112\t    def check_thread(self) -> None:\n113\t        kwargs = {\n114\t            'allow_redirect...\n116\t        if self.app.config.linkcheck_timeout:\n117\t            kwargs['timeout'] = self.app.config.linkcheck_timeout\n118\n120\t            url = urlparse(uri)\n122\t                          \"%s://%s/\" % (url.scheme, url.netloc),\n121\t            candidates = [\"%s://%s\" % (url.scheme, url.ne...\n123\t                          uri,\n124\t                          \"*\"]\n125\n126\t            for u in candidates:\n127\t                if u in self.config.linkcheck_request_headers:\n129\t                    headers.update(self.config.linkcheck_request_headers[u])\n131\n133\n134\t        def check_uri() -> Tuple[str, str, int]:\n135\t            # split off anchor\n137\t                req_url, anchor = uri....\n138\t                for rex in self.anchors_ignore:\n140\t                        anchor = None\n139\t                    if rex.match(anchor):\n141\t                        break\n142\t            else:\n144\t                anchor = None\n145\n146\t            # handle non-ASCII URIs\n147\t            try:\n149\t            except UnicodeError:\n150\t                req_url = encode_uri(req_url)\n151\n152\t            # Get auth info, if any\n155\t                    break\n153\t            for pattern, auth_info in self.auth:\n158\n** output may be incomplete **\n157\t                auth_info = None\n159\t            # update request headers for the URL\n160\t            kwargs['headers'] = get_request_headers()\n161\n164\t                    # Read the whole document and see if #anchor exists\n163\t                if anchor and self.app.config.linkcheck_anchors:\n166\t                                            auth=auth_info, **kwargs)\n167\t                    found = check_anchor(response, unquote(anchor))\n170\t                        raise Exception(__(\"Anchor '%s' not found\") % anchor)\n171\t                else:\n172\t                    try:\n174\t                        # the server and the network\n176\t                                                 auth=auth_info, **kwargs)\n175\t                        response = requests.head(req_url, config=self.app.config,\n178\t                    except HTTPError:\n177\t                        response.raise_for_status()\n179\t                        # retry with GET request if that fails, some servers\n181\t                        response = requests.get(req_url, stream=True, config=self.app.config,\n182\t                                                auth=auth_info, **kwargs)\n187\t                    return 'working', ' - unauthorized', 0\n183\t                        response.raise_for_status()\n188\t                elif err.resp...\n189\t                    # We'll take \"Service Unavailable\" as ignored.\n190\t                    retur...\n192\t                 ...\n191\t                else:\n193\t            except Exception as err:\n194\t                if is_ssl_error(err):\n195\t                    return 'ignored', str(err), 0\n196\t                else:\n198\t            if response.url.rstrip('/') == req_url.rstrip('/'):\n197\t                    return 'broken', str(err), 0\n199\t                return 'working', '', 0\n202\t                if anchor:\n203\t                    new_url += '#' + anchor\n204\t                # history contains any redirects, ge...\n205\t                if response.history:\n206\t                    code = response.history[-1].status_code\n208\t                else:\n210\n209\t                    return 'redir...\n211\t        def check() -> Tuple[str, str, int]:\n214\t                return 'unchecked', '', 0\n216\t                return 'local...\n215\t            elif not uri.starts...\n217\t            elif uri in self.good:\n220\t                return 'broken', self.broken[uri], 0\n219\t            elif uri in self.broken:\n221\t            elif uri in self.redirected:\n222\t                return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n225\t                    return 'ignored', '', 0\n224\t                if rex.match(uri):\n226\n227\t            # need to actually check the URI\n228\t            for _ in range(self.app.config.linkcheck_retries):\n229\t                status, info, code = check_uri()\n230\t                if status != \"broken\":\n232\n233\t            if status == \"working\":\n234\t                self.good.add(uri)\n235\t            elif status == \"broken\":\n239\n238\t                self.redirected[uri] = (info, code)\n240\t            return (status, info, code)\n241\n242\t        while True:\n243\t            uri, docname, lineno = self.wqueue.get()\n244\t            if uri is None:\n246\t            status, info, code = check()\n247\t            self.rqueue.put((uri, docname, lineno, status, info, code))\n248\n251\n250\t        uri, docname, lineno, status, info, code = result\n252\t        filename = self.env.doc2path(docname, None)\n254\t                        status=status, code=code, uri=uri,\n255\t                        info=info)\n257\t            self.write_linkstat(linkstat)\n258\t            return\n259\t        if status == 'working' and info == 'old':\n260\t            self.write_linkstat(linkstat)",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba sphinx/builders/linkcheck.py | sed -n '200,340p'",
      "original": "   200\t            else:\n   201\t                new_url = response.url\n   202\t                if anchor:\n   203\t                    new_url += '#' + anchor\n   204\t                # history contains any redirects, get last\n   205\t                if response.history:\n   206\t                    code = response.history[-1].status_code\n   207\t                    return 'redirected', new_url, code\n   208\t                else:\n   209\t                    return 'redirected', new_url, 0\n   210\t\n   211\t        def check() -> Tuple[str, str, int]:\n   212\t            # check for various conditions without bothering the network\n   213\t            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n   214\t                return 'unchecked', '', 0\n   215\t            elif not uri.startswith(('http:', 'https:')):\n   216\t                return 'local', '', 0\n   217\t            elif uri in self.good:\n   218\t                return 'working', 'old', 0\n   219\t            elif uri in self.broken:\n   220\t                return 'broken', self.broken[uri], 0\n   221\t            elif uri in self.redirected:\n   222\t                return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n   223\t            for rex in self.to_ignore:\n   224\t                if rex.match(uri):\n   225\t                    return 'ignored', '', 0\n   226\t\n   227\t            # need to actually check the URI\n   228\t            for _ in range(self.app.config.linkcheck_retries):\n   229\t                status, info, code = check_uri()\n   230\t                if status != \"broken\":\n   231\t                    break\n   232\t\n   233\t            if status == \"working\":\n   234\t                self.good.add(uri)\n   235\t            elif status == \"broken\":\n   236\t                self.broken[uri] = info\n   237\t            elif status == \"redirected\":\n   238\t                self.redirected[uri] = (info, code)\n   239\t\n   240\t            return (status, info, code)\n   241\t\n   242\t        while True:\n   243\t            uri, docname, lineno = self.wqueue.get()\n   244\t            if uri is None:\n   245\t                break\n   246\t            status, info, code = check()\n   247\t            self.rqueue.put((uri, docname, lineno, status, info, code))\n   248\t\n   249\t    def process_result(self, result: Tuple[str, str, int, str, str, int]) -> None:\n   250\t        uri, docname, lineno, status, info, code = result\n   251\t\n   252\t        filename = self.env.doc2path(docname, None)\n   253\t        linkstat = dict(filename=filename, lineno=lineno,\n   254\t                        status=status, code=code, uri=uri,\n   255\t                        info=info)\n   256\t        if status == 'unchecked':\n   257\t            self.write_linkstat(linkstat)\n   258\t            return\n   259\t        if status == 'working' and info == 'old':\n   260\t            self.write_linkstat(linkstat)\n   261\t            return\n   262\t        if lineno:\n   263\t            logger.info('(line %4d) ', lineno, nonl=True)\n   264\t        if status == 'ignored':\n   265\t            if info:\n   266\t                logger.info(darkgray('-ignored- ') + uri + ': ' + info)\n   267\t            else:\n   268\t                logger.info(darkgray('-ignored- ') + uri)\n   269\t            self.write_linkstat(linkstat)\n   270\t        elif status == 'local':\n   271\t            logger.info(darkgray('-local-   ') + uri)\n   272\t            self.write_entry('local', docname, filename, lineno, uri)\n   273\t            self.write_linkstat(linkstat)\n   274\t        elif status == 'working':\n   275\t            logger.info(darkgreen('ok        ') + uri + info)\n   276\t            self.write_linkstat(linkstat)\n   277\t        elif status == 'broken':\n   278\t            if self.app.quiet or self.app.warningiserror:\n   279\t                logger.warning(__('broken link: %s (%s)'), uri, info,\n   280\t                               location=(filename, lineno))\n   281\t            else:\n   282\t                logger.info(red('broken    ') + uri + red(' - ' + info))\n   283\t            self.write_entry('broken', docname, filename, lineno, uri + ': ' + info)\n   284\t            self.write_linkstat(linkstat)\n   285\t        elif status == 'redirected':\n   286\t            try:\n   287\t                text, color = {\n   288\t                    301: ('permanently', purple),\n   289\t                    302: ('with Found', purple),\n   290\t                    303: ('with See Other', purple),\n   291\t                    307: ('temporarily', turquoise),\n   292\t                    308: ('permanently', purple),\n   293\t                }[code]\n   294\t            except KeyError:\n   295\t                text, color = ('with unknown code', purple)\n   296\t            linkstat['text'] = text\n   297\t            logger.info(color('redirect  ') + uri + color(' - ' + text + ' to ' + info))\n   298\t            self.write_entry('redirected ' + text, docname, filename,\n   299\t                             lineno, uri + ' to ' + info)\n   300\t            self.write_linkstat(linkstat)\n   301\t\n   302\t    def get_target_uri(self, docname: str, typ: str = None) -> str:\n   303\t        return ''\n   304\t\n   305\t    def get_outdated_docs(self) -> Set[str]:\n   306\t        return self.env.found_docs\n   307\t\n   308\t    def prepare_writing(self, docnames: Set[str]) -> None:\n   309\t        return\n   310\t\n   311\t    def write_doc(self, docname: str, doctree: Node) -> None:\n   312\t        logger.info('')\n   313\t        n = 0\n   314\t\n   315\t        # reference nodes\n   316\t        for refnode in doctree.traverse(nodes.reference):\n   317\t            if 'refuri' not in refnode:\n   318\t                continue\n   319\t            uri = refnode['refuri']\n   320\t            lineno = get_node_line(refnode)\n   321\t            self.wqueue.put((uri, docname, lineno), False)\n   322\t            n += 1\n   323\t\n   324\t        # image nodes\n   325\t        for imgnode in doctree.traverse(nodes.image):\n   326\t            uri = imgnode['candidates'].get('?')\n   327\t            if uri and '://' in uri:\n   328\t                lineno = get_node_line(imgnode)\n   329\t                self.wqueue.put((uri, docname, lineno), False)\n   330\t                n += 1\n   331\t\n   332\t        done = 0\n   333\t        while done < n:\n   334\t            self.process_result(self.rqueue.get())\n   335\t            done += 1\n   336\t\n   337\t        if self.broken:\n   338\t            self.app.statuscode = 1\n   339\t\n   340\t    def write_entry(self, what: str, docname: str, filename: str, line: int,\n",
      "perturbed": "200\t            else:\n202\t                if anchor:\n201\t                new_url = response.url\n203\t                    new_url...\n206\t                    cod...\n207\t                   ...\n209\t                    return 'redirected', new_url, 0\n210\n211\t        def check() -> Tuple[str, str, int]:\n212\t            # check for various conditions without bothering the network\n213\t            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n217\t            elif uri in self.good:\n219\t            elif uri in self.broken:\n222\t                return 'redirected', ...\n220\t                return 'broken', self.broken[uri], 0\n223\t            for rex in self.to_ignore:\n224\t                if rex.match(uri):\n225\t                    return 'ignored', '', 0\n226\n228\t            for _ in range(self.app.config.linkcheck_retries):\n227\t            # need to actually check the URI\n231\t                    break\n230\t                if status != \"broken\":\n233\t            if status == \"working\":\n232\n234\t                self.good.add(uri)\n235\t            elif status == \"broken\":\n236\t                self.broken[uri] = info\n238\t                self.redirected[uri] = (info, code)\n240\t            return (status, info, ...\n241\n242\t        while True:\n243\t            uri, docname, lineno = self.wqueue.get()\n247\t            self.rqueue.put((uri, docname, lineno, status, info, code))\n246\t            status, info, code = check()\n249\t    def process_result(self, result: Tuple[str, str, int, str, str, int]) -> None:\n251\n250\t        uri, docname, lineno, status, info, code = result\n252\t        filename = self.env.doc2path(docname, None)\n254\t                        status=status, code=code, uri=uri,\n253\t        linkstat = dict(filename=filename, lineno=lineno,\n255\t                        info=info)\n256\t        if status == 'unchecked':\n257\t            self.write_linkstat(linkstat)\n260\t            self.write_linkstat(linkstat)\n258\t            return\n261\t            return\n263\t            logger.info('(line %4d) ', lineno, nonl=True)\n262\t        if lineno:\n265\t            if info:\n267\t            else:\n268\t                logger.info(darkgray('-ignored- ') + uri)\n269\t            self.write_linkstat(linkstat)\n270\t        elif status == 'local':\n271\t            logger.info(darkgray('-local-   ') + uri)\n273\t            self.write_linkstat(linkstat)\n272\t            self.wr...\n274\t        elif status == 'working':\n275\t            logger.info(darkgreen('ok        ') + uri + info)\n276\t            self.write_lin...\n278\t            if self.app.quiet or self.app.warningiserror:\n277\t        elif status == 'broken':\n280\t                               location=(filename, lineno))\n281\t            else:\n282\t                logger.info(red('broken    ') + uri + red(' - ' + info))\n284\t            self.w...\n283\t            self.write_entry('broken', docname, filename, lineno, uri + ': ' + info)\n286\t            try:\n288\t                    301: ('permanently', purple),\n287\t                text, color = {\n289\t                    302: ('with Found', purple),\n291\t                    307: ('temporarily', turquoise),\n292\t                    308: ('p...\n293\t                }[code]\n294\t            except KeyError:\n296\t            linkstat['text'] = text\n295\t                text, color = ('with unknown code', purple)\n298\t            self.write_entry('redirected ' + text, docname, filename,\n297\t            logger.info(color('redirect  ') + uri + color(' - ' + text + ' to ' + info))\n299\t                             lineno, uri + ' to ' + info)\n301\n302\t    def get_target_uri(self, docname...\n304\n303\t        return ''\n307\n308\t    def prepare_writing(self,...\n309\t        return\n310\n311\t    def write_doc(self, docname: str, doctree: Node) -> None:\n313\t        n = 0\n312\t        logger.info('')\n314\n315\t        # reference nodes\n317\t            if 'refuri' not in refnode:\n318\t                continue\n319\t            uri = refnode...\n320\t            lineno = get_node_line(refnode)\n321\t            self.wqueue.put((uri, docname, lineno), False)\n323\n324\t        # image nodes\n325\t        for imgnode in doctree.traverse(nodes.image):\n326\t            uri = imgnode['candidates'].get('?')\n329\t                self.wqueue.put((uri, docname, lineno), False)\n328\t                lineno = get_node_line(imgnode)\n330\t                n += 1\n331\n332\t        done = 0\n333\t        while done < n:\n338\t            self.app.statuscode = 1\n337\t        if self.broken:\n340\t    def write_entry(self, what: str, docname: str, filename: str, line: int,\n339",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "grep -n \"local\" -n sphinx/builders/linkcheck.py || true",
      "original": "27:from sphinx.locale import __\n216:                return 'local', '', 0\n270:        elif status == 'local':\n271:            logger.info(darkgray('-local-   ') + uri)\n272:            self.write_entry('local', docname, filename, lineno, uri)\n",
      "perturbed": "27:from sphinx.locale import __\n216:                return 'local', '', 0\n270:        elif status == 'local':\n271:            logger.info(darkgray('-local-   ') + uri)\n272:            self.write_entry('local', docname, filename, lineno, uri)",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba sphinx/builders/linkcheck.py | sed -n '300,999p'",
      "original": "   300\t            self.write_linkstat(linkstat)\n   301\t\n   302\t    def get_target_uri(self, docname: str, typ: str = None) -> str:\n   303\t        return ''\n   304\t\n   305\t    def get_outdated_docs(self) -> Set[str]:\n   306\t        return self.env.found_docs\n   307\t\n   308\t    def prepare_writing(self, docnames: Set[str]) -> None:\n   309\t        return\n   310\t\n   311\t    def write_doc(self, docname: str, doctree: Node) -> None:\n   312\t        logger.info('')\n   313\t        n = 0\n   314\t\n   315\t        # reference nodes\n   316\t        for refnode in doctree.traverse(nodes.reference):\n   317\t            if 'refuri' not in refnode:\n   318\t                continue\n   319\t            uri = refnode['refuri']\n   320\t            lineno = get_node_line(refnode)\n   321\t            self.wqueue.put((uri, docname, lineno), False)\n   322\t            n += 1\n   323\t\n   324\t        # image nodes\n   325\t        for imgnode in doctree.traverse(nodes.image):\n   326\t            uri = imgnode['candidates'].get('?')\n   327\t            if uri and '://' in uri:\n   328\t                lineno = get_node_line(imgnode)\n   329\t                self.wqueue.put((uri, docname, lineno), False)\n   330\t                n += 1\n   331\t\n   332\t        done = 0\n   333\t        while done < n:\n   334\t            self.process_result(self.rqueue.get())\n   335\t            done += 1\n   336\t\n   337\t        if self.broken:\n   338\t            self.app.statuscode = 1\n   339\t\n   340\t    def write_entry(self, what: str, docname: str, filename: str, line: int,\n   341\t                    uri: str) -> None:\n   342\t        with open(path.join(self.outdir, 'output.txt'), 'a') as output:\n   343\t            output.write(\"%s:%s: [%s] %s\\n\" % (filename, line, what, uri))\n   344\t\n   345\t    def write_linkstat(self, data: dict) -> None:\n   346\t        with open(path.join(self.outdir, 'output.json'), 'a') as output:\n   347\t            output.write(json.dumps(data))\n   348\t            output.write('\\n')\n   349\t\n   350\t    def finish(self) -> None:\n   351\t        for worker in self.workers:\n   352\t            self.wqueue.put((None, None, None), False)\n   353\t\n   354\t\n   355\tdef setup(app: Sphinx) -> Dict[str, Any]:\n   356\t    app.add_builder(CheckExternalLinksBuilder)\n   357\t\n   358\t    app.add_config_value('linkcheck_ignore', [], None)\n   359\t    app.add_config_value('linkcheck_auth', [], None)\n   360\t    app.add_config_value('linkcheck_request_headers', {}, None)\n   361\t    app.add_config_value('linkcheck_retries', 1, None)\n   362\t    app.add_config_value('linkcheck_timeout', None, None, [int])\n   363\t    app.add_config_value('linkcheck_workers', 5, None)\n   364\t    app.add_config_value('linkcheck_anchors', True, None)\n   365\t    # Anchors starting with ! are ignored since they are\n   366\t    # commonly used for dynamic pages\n   367\t    app.add_config_value('linkcheck_anchors_ignore', [\"^!\"], None)\n   368\t\n   369\t    return {\n   370\t        'version': 'builtin',\n   371\t        'parallel_read_safe': True,\n   372\t        'parallel_write_safe': True,\n   373\t    }\n",
      "perturbed": "300\t            self.write...\n301\n302\t    def get_target_uri(self, docname: str, typ: str = None) -> str:\n303\t        return ''\n304\n305\t    def get_outda...\n306\t        return self.env....\n308\t    def prepare_writing(self, docnames: Set[str]) -> None:\n309\t        return\n310\n311\t    def write_doc(self, docname: str, doctree: Node) -> None:\n312\t        logger.info('')\n313\t        n = 0\n315\t        # reference nodes\n314\n317\t            if 'refuri' not in refnode:\n316\t        for refnode in doctree.traverse(nodes.reference):\n318\t                continue\n319\t            uri = refnode['refuri']\n320\t            lineno = get_node_line(refnode)\n322\t            n += 1\n323\n324\t        # image nodes\n325\t        for imgnode in doctree.traverse(nodes.image):\n326\t            uri = imgnode['candidates'].get('?')\n328\t                lineno = get_node_line(imgnode)\n330\t                n += 1\n329\t                self.wqueue.put((uri, docname, lineno), False)\n331\n332\t        done = 0\n334\t            self.process_result(self.rqueue.get())\n336\n335\t            done += 1\n337\t        if self.broken:\n340\t    def write_entry(self, what: str, do...\n339\n341\t                    uri: str) -> None:\n342\t        with open(path.join(self.outdir, 'output.txt'), 'a') as output:\n343\t            output.write(\"%s:%s: [%s] %s\\n\" % (filename, line, what, uri))\n344\n345\t    def write_linkstat(self, data: dict) -> None:\n346\t        with open(path.join(self.outdir, 'output.json'), 'a') as output:\n350\t    def finish(self) -> None:\n348\t            output.write('\\n')\n351\t        for worker in self.workers:\n352\t            self.wqueue.put((None, None, None), False)\n353\n354\n355\tdef setup(app: Sphinx) -> Dict[str, Any]:\n356\t    app.add_builder(CheckExternalLinksBuilder)\n357\n358\t    app.add_config_value('linkcheck_ignore', [], None)\n359\t    app.add_config_value('linkcheck_auth', [], None)\n360\t    app.add_config_value('linkcheck_request_headers', {}, None)\n361\t    app.add_config_value('linkcheck_retries', 1, None)\n364\t    app.add_config_value('linkcheck_anchors', True, None)\n367\t    app.add_config_value('linkcheck_anchors_ignore', [\"^!\"], None)\n366\t    # commonly used for dynami...\n369\t    return {\n370\t        'version': 'builtin',\n371\t        'parallel_read_safe': True,\n372\t        'parallel_write_safe': True,\n373\t    }",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba sphinx/project.py | sed -n '1,240p'",
      "original": "     1\t\"\"\"\n     2\t    sphinx.project\n     3\t    ~~~~~~~~~~~~~~\n     4\t\n     5\t    Utility function and classes for Sphinx projects.\n     6\t\n     7\t    :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n     8\t    :license: BSD, see LICENSE for details.\n     9\t\"\"\"\n    10\t\n    11\timport os\n    12\tfrom glob import glob\n    13\t\n    14\tfrom sphinx.locale import __\n    15\tfrom sphinx.util import get_matching_files\n    16\tfrom sphinx.util import logging\n    17\tfrom sphinx.util import path_stabilize\n    18\tfrom sphinx.util.matching import compile_matchers\n    19\tfrom sphinx.util.osutil import SEP, relpath\n    20\t\n    21\tif False:\n    22\t    # For type annotation\n    23\t    from typing import Dict, List, Set  # NOQA\n    24\t\n    25\t\n    26\tlogger = logging.getLogger(__name__)\n    27\tEXCLUDE_PATHS = ['**/_sources', '.#*', '**/.#*', '*.lproj/**']\n    28\t\n    29\t\n    30\tclass Project:\n    31\t    \"\"\"A project is source code set of Sphinx document.\"\"\"\n    32\t\n    33\t    def __init__(self, srcdir, source_suffix):\n    34\t        # type: (str, Dict[str, str]) -> None\n    35\t        #: Source directory.\n    36\t        self.srcdir = srcdir\n    37\t\n    38\t        #: source_suffix. Same as :confval:`source_suffix`.\n    39\t        self.source_suffix = source_suffix\n    40\t\n    41\t        #: The name of documents belongs to this project.\n    42\t        self.docnames = set()  # type: Set[str]\n    43\t\n    44\t    def restore(self, other):\n    45\t        # type: (Project) -> None\n    46\t        \"\"\"Take over a result of last build.\"\"\"\n    47\t        self.docnames = other.docnames\n    48\t\n    49\t    def discover(self, exclude_paths=[]):\n    50\t        # type: (List[str]) -> Set[str]\n    51\t        \"\"\"Find all document files in the source directory and put them in\n    52\t        :attr:`docnames`.\n    53\t        \"\"\"\n    54\t        self.docnames = set()\n    55\t        excludes = compile_matchers(exclude_paths + EXCLUDE_PATHS)\n    56\t        for filename in get_matching_files(self.srcdir, excludes):  # type: ignore\n    57\t            docname = self.path2doc(filename)\n    58\t            if docname:\n    59\t                if docname in self.docnames:\n    60\t                    pattern = os.path.join(self.srcdir, docname) + '.*'\n    61\t                    files = [relpath(f, self.srcdir) for f in glob(pattern)]\n    62\t                    logger.warning(__('multiple files found for the document \"%s\": %r\\n'\n    63\t                                      'Use %r for the build.'),\n    64\t                                   docname, files, self.doc2path(docname), once=True)\n    65\t                elif os.access(os.path.join(self.srcdir, filename), os.R_OK):\n    66\t                    self.docnames.add(docname)\n    67\t                else:\n    68\t                    logger.warning(__(\"document not readable. Ignored.\"), location=docname)\n    69\t\n    70\t        return self.docnames\n    71\t\n    72\t    def path2doc(self, filename):\n    73\t        # type: (str) -> str\n    74\t        \"\"\"Return the docname for the filename if the file is document.\n    75\t\n    76\t        *filename* should be absolute or relative to the source directory.\n    77\t        \"\"\"\n    78\t        if filename.startswith(self.srcdir):\n    79\t            filename = relpath(filename, self.srcdir)\n    80\t        for suffix in self.source_suffix:\n    81\t            if filename.endswith(suffix):\n    82\t                filename = path_stabilize(filename)\n    83\t                return filename[:-len(suffix)]\n    84\t\n    85\t        # the file does not have docname\n    86\t        return None\n    87\t\n    88\t    def doc2path(self, docname, basedir=True):\n    89\t        # type: (str, bool) -> str\n    90\t        \"\"\"Return the filename for the document name.\n    91\t\n    92\t        If *basedir* is True, return as an absolute path.\n    93\t        Else, return as a relative path to the source directory.\n    94\t        \"\"\"\n    95\t        docname = docname.replace(SEP, os.path.sep)\n    96\t        basename = os.path.join(self.srcdir, docname)\n    97\t        for suffix in self.source_suffix:\n    98\t            if os.path.isfile(basename + suffix):\n    99\t                break\n   100\t        else:\n   101\t            # document does not exist\n   102\t            suffix = list(self.source_suffix)[0]\n   103\t\n   104\t        if basedir:\n   105\t            return basename + suffix\n   106\t        else:\n   107\t            return docname + suffix\n",
      "perturbed": "3\t    ~~~~~~~~~~~~~~\n2\t    sphinx.project\n5\t    Utility function and classes for Sphinx projects.\n9\t\"\"\"\n7\t    :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n10\n11\timport os\n12\tfrom glob import glob\n13\n14\tfrom sphinx.locale import __\n15\tfrom sphinx.util import get_matching_files\n16\tfrom sphinx.util import logging\n18\tfrom sphinx.util.matching import compile_matchers\n20\n21\tif False:\n22\t    # For type annotation\n23\t    from typing import Dict, List, Set  # NOQA\n24\n26\tlogger = loggi...\n25\n27\tEXCLUDE_PATHS = ['**/_sources', '.#*', '**/.#*', '*.lproj/**']\n28\n30\tclass Project:\n31\t    \"\"\"A project is source code set of Sphinx document.\"\"\"\n32\n34\t        # type: (str, Dict[str, str]) -> None\n33\t    def __init__(self, srcdir, source_...\n35\t        #: Source directory.\n36\t        self.srcdir = srcdir\n38\t        #: source_suffix. Same as :confval:`source_suffix`.\n39\t        self.source_suffix = source_suffix\n40\n41\t        #: The name of documents belongs to this project.\n42\t        self.docnames = set()  # type: Set[str]\n44\t    def restore(self, other):\n48\n47\t        self.docnames = other.docnames\n49\t    def discover(self, e...\n50\t        # type: (List[str]) -> Set[str]\n51\t        \"\"\"Find all document files in the source directory and put them in\n52\t        :attr:`docnames`.\n54\t        self.docnames = set()\n55\t        exclud...\n57\t            docname = self.path2doc(filename)\n58\t            if docname:\n59\t                if docname in sel...\n61\t                    files = [relpath(f, self.srcdir) for f in glob(patt...\n63\t                                      'Use %r for the build.'),\n64\t                                   docname, files, self.doc2path(docname), once=True)\n67\t                else:\n65\t                elif os.access(os.path.join(self....\n69\n68\t                    logger.warning(__(\"document not readable. Ignored.\"), location=docname)\n70\t        return self.docnames\n71\n72\t    def path2doc(self, filename):\n75\n73\t        # type: (str) -> str\n76\t        *filename* should be absolut...\n77\t        \"\"\"\n78\t        if filename.startswith(self.srcdir):\n79\t            filename = relpath(filename, self.srcdir)\n81\t            if filename.endswith(suffix):\n84\n85\t        # the file does not have docname\n86\t        return None\n87\n88\t    def doc2path(self, do...\n89\t        # type: (str, bool) -> str\n90\t        \"\"\"Return the filename for the document name.\n92\t        If *basedir* is True, return as...\n91\n95\t        docname = docname.replace(SEP, os.path.sep)\n93\t        Else, return as a relative path to the source directory.\n99\t                break\n98\t            if os.path.isfile(basename + suffix):\n100\t        else:\n101\t            # document does not exist\n102\t            suffix = list(self.source_suffix)[0]\n104\t        if basedir:\n106\t        else:\n105\t            return basename + suffix\n107\t            return docname + suffix",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba sphinx/environment/__init__.py | sed -n '1,260p'",
      "original": "     1\t\"\"\"\n     2\t    sphinx.environment\n     3\t    ~~~~~~~~~~~~~~~~~~\n     4\t\n     5\t    Global creation environment.\n     6\t\n     7\t    :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n     8\t    :license: BSD, see LICENSE for details.\n     9\t\"\"\"\n    10\t\n    11\timport os\n    12\timport pickle\n    13\timport warnings\n    14\tfrom collections import defaultdict\n    15\tfrom copy import copy\n    16\tfrom os import path\n    17\tfrom typing import Any, Callable, Dict, Generator, Iterator, List, Set, Tuple, Union\n    18\tfrom typing import cast\n    19\t\n    20\tfrom docutils import nodes\n    21\tfrom docutils.nodes import Node\n    22\t\n    23\tfrom sphinx import addnodes\n    24\tfrom sphinx.config import Config\n    25\tfrom sphinx.deprecation import RemovedInSphinx40Warning\n    26\tfrom sphinx.domains import Domain\n    27\tfrom sphinx.environment.adapters.toctree import TocTree\n    28\tfrom sphinx.errors import SphinxError, BuildEnvironmentError, DocumentError, ExtensionError\n    29\tfrom sphinx.events import EventManager\n    30\tfrom sphinx.locale import __\n    31\tfrom sphinx.project import Project\n    32\tfrom sphinx.transforms import SphinxTransformer\n    33\tfrom sphinx.util import DownloadFiles, FilenameUniqDict\n    34\tfrom sphinx.util import logging\n    35\tfrom sphinx.util.docutils import LoggingReporter\n    36\tfrom sphinx.util.i18n import CatalogRepository, docname_to_domain\n    37\tfrom sphinx.util.nodes import is_translatable\n    38\t\n    39\tif False:\n    40\t    # For type annotation\n    41\t    from sphinx.application import Sphinx\n    42\t    from sphinx.builders import Builder\n    43\t\n    44\t\n    45\tlogger = logging.getLogger(__name__)\n    46\t\n    47\tdefault_settings = {\n    48\t    'embed_stylesheet': False,\n    49\t    'cloak_email_addresses': True,\n    50\t    'pep_base_url': 'https://www.python.org/dev/peps/',\n    51\t    'pep_references': None,\n    52\t    'rfc_base_url': 'https://tools.ietf.org/html/',\n    53\t    'rfc_references': None,\n    54\t    'input_encoding': 'utf-8-sig',\n    55\t    'doctitle_xform': False,\n    56\t    'sectsubtitle_xform': False,\n    57\t    'halt_level': 5,\n    58\t    'file_insertion_enabled': True,\n    59\t    'smartquotes_locales': [],\n    60\t}  # type: Dict[str, Any]\n    61\t\n    62\t# This is increased every time an environment attribute is added\n    63\t# or changed to properly invalidate pickle files.\n    64\tENV_VERSION = 56\n    65\t\n    66\t# config status\n    67\tCONFIG_OK = 1\n    68\tCONFIG_NEW = 2\n    69\tCONFIG_CHANGED = 3\n    70\tCONFIG_EXTENSIONS_CHANGED = 4\n    71\t\n    72\tCONFIG_CHANGED_REASON = {\n    73\t    CONFIG_NEW: __('new config'),\n    74\t    CONFIG_CHANGED: __('config changed'),\n    75\t    CONFIG_EXTENSIONS_CHANGED: __('extensions changed'),\n    76\t}\n    77\t\n    78\t\n    79\tversioning_conditions = {\n    80\t    'none': False,\n    81\t    'text': is_translatable,\n    82\t}  # type: Dict[str, Union[bool, Callable]]\n    83\t\n    84\t\n    85\tclass BuildEnvironment:\n    86\t    \"\"\"\n    87\t    The environment in which the ReST files are translated.\n    88\t    Stores an inventory of cross-file targets and provides doctree\n    89\t    transformations to resolve links to them.\n    90\t    \"\"\"\n    91\t\n    92\t    domains = None  # type: Dict[str, Domain]\n    93\t\n    94\t    # --------- ENVIRONMENT INITIALIZATION -------------------------------------\n    95\t\n    96\t    def __init__(self, app: \"Sphinx\" = None):\n    97\t        self.app = None                  # type: Sphinx\n    98\t        self.doctreedir = None           # type: str\n    99\t        self.srcdir = None               # type: str\n   100\t        self.config = None               # type: Config\n   101\t        self.config_status = None        # type: int\n   102\t        self.config_status_extra = None  # type: str\n   103\t        self.events = None               # type: EventManager\n   104\t        self.project = None              # type: Project\n   105\t        self.version = None              # type: Dict[str, str]\n   106\t\n   107\t        # the method of doctree versioning; see set_versioning_method\n   108\t        self.versioning_condition = None  # type: Union[bool, Callable]\n   109\t        self.versioning_compare = None  # type: bool\n   110\t\n   111\t        # all the registered domains, set by the application\n   112\t        self.domains = {}\n   113\t\n   114\t        # the docutils settings for building\n   115\t        self.settings = default_settings.copy()\n   116\t        self.settings['env'] = self\n   117\t\n   118\t        # All \"docnames\" here are /-separated and relative and exclude\n   119\t        # the source suffix.\n   120\t\n   121\t        self.all_docs = {}          # type: Dict[str, float]\n   122\t                                    # docname -> mtime at the time of reading\n   123\t                                    # contains all read docnames\n   124\t        self.dependencies = defaultdict(set)    # type: Dict[str, Set[str]]\n   125\t                                    # docname -> set of dependent file\n   126\t                                    # names, relative to documentation root\n   127\t        self.included = defaultdict(set)        # type: Dict[str, Set[str]]\n   128\t                                    # docname -> set of included file\n   129\t                                    # docnames included from other documents\n   130\t        self.reread_always = set()  # type: Set[str]\n   131\t                                    # docnames to re-read unconditionally on\n   132\t                                    # next build\n   133\t\n   134\t        # File metadata\n   135\t        self.metadata = defaultdict(dict)       # type: Dict[str, Dict[str, Any]]\n   136\t                                                # docname -> dict of metadata items\n   137\t\n   138\t        # TOC inventory\n   139\t        self.titles = {}            # type: Dict[str, nodes.title]\n   140\t                                    # docname -> title node\n   141\t        self.longtitles = {}        # type: Dict[str, nodes.title]\n   142\t                                    # docname -> title node; only different if\n   143\t                                    # set differently with title directive\n   144\t        self.tocs = {}              # type: Dict[str, nodes.bullet_list]\n   145\t                                    # docname -> table of contents nodetree\n   146\t        self.toc_num_entries = {}   # type: Dict[str, int]\n   147\t                                    # docname -> number of real entries\n   148\t\n   149\t        # used to determine when to show the TOC\n   150\t        # in a sidebar (don't show if it's only one item)\n   151\t        self.toc_secnumbers = {}    # type: Dict[str, Dict[str, Tuple[int, ...]]]\n   152\t                                    # docname -> dict of sectionid -> number\n   153\t        self.toc_fignumbers = {}    # type: Dict[str, Dict[str, Dict[str, Tuple[int, ...]]]]\n   154\t                                    # docname -> dict of figtype ->\n   155\t                                    # dict of figureid -> number\n   156\t\n   157\t        self.toctree_includes = {}  # type: Dict[str, List[str]]\n   158\t                                    # docname -> list of toctree includefiles\n   159\t        self.files_to_rebuild = {}  # type: Dict[str, Set[str]]\n   160\t                                    # docname -> set of files\n   161\t                                    # (containing its TOCs) to rebuild too\n   162\t        self.glob_toctrees = set()  # type: Set[str]\n   163\t                                    # docnames that have :glob: toctrees\n   164\t        self.numbered_toctrees = set()  # type: Set[str]\n   165\t                                        # docnames that have :numbered: toctrees\n   166\t\n   167\t        # domain-specific inventories, here to be pickled\n   168\t        self.domaindata = {}        # type: Dict[str, Dict]\n   169\t                                    # domainname -> domain-specific dict\n   170\t\n   171\t        # these map absolute path -> (docnames, unique filename)\n   172\t        self.images = FilenameUniqDict()    # type: FilenameUniqDict\n   173\t        self.dlfiles = DownloadFiles()      # type: DownloadFiles\n   174\t                                            # filename -> (set of docnames, destination)\n   175\t\n   176\t        # the original URI for images\n   177\t        self.original_image_uri = {}  # type: Dict[str, str]\n   178\t\n   179\t        # temporary data storage while reading a document\n   180\t        self.temp_data = {}         # type: Dict[str, Any]\n   181\t        # context for cross-references (e.g. current module or class)\n   182\t        # this is similar to temp_data, but will for example be copied to\n   183\t        # attributes of \"any\" cross references\n   184\t        self.ref_context = {}       # type: Dict[str, Any]\n   185\t\n   186\t        # set up environment\n   187\t        if app:\n   188\t            self.setup(app)\n   189\t\n   190\t    def __getstate__(self) -> Dict:\n   191\t        \"\"\"Obtains serializable data for pickling.\"\"\"\n   192\t        __dict__ = self.__dict__.copy()\n   193\t        __dict__.update(app=None, domains={}, events=None)  # clear unpickable attributes\n   194\t        return __dict__\n   195\t\n   196\t    def __setstate__(self, state: Dict) -> None:\n   197\t        self.__dict__.update(state)\n   198\t\n   199\t    def setup(self, app: \"Sphinx\") -> None:\n   200\t        \"\"\"Set up BuildEnvironment object.\"\"\"\n   201\t        if self.version and self.version != app.registry.get_envversion(app):\n   202\t            raise BuildEnvironmentError(__('build environment version not current'))\n   203\t        elif self.srcdir and self.srcdir != app.srcdir:\n   204\t            raise BuildEnvironmentError(__('source directory has changed'))\n   205\t\n   206\t        if self.project:\n   207\t            app.project.restore(self.project)\n   208\t\n   209\t        self.app = app\n   210\t        self.doctreedir = app.doctreedir\n   211\t        self.events = app.events\n   212\t        self.srcdir = app.srcdir\n   213\t        self.project = app.project\n   214\t        self.version = app.registry.get_envversion(app)\n   215\t\n   216\t        # initialize domains\n   217\t        self.domains = {}\n   218\t        for domain in app.registry.create_domains(self):\n   219\t            self.domains[domain.name] = domain\n   220\t\n   221\t        # setup domains (must do after all initialization)\n   222\t        for domain in self.domains.values():\n   223\t            domain.setup()\n   224\t\n   225\t        # initialize config\n   226\t        self._update_config(app.config)\n   227\t\n   228\t        # initialie settings\n   229\t        self._update_settings(app.config)\n   230\t\n   231\t    def _update_config(self, config: Config) -> None:\n   232\t        \"\"\"Update configurations by new one.\"\"\"\n   233\t        self.config_status = CONFIG_OK\n   234\t        self.config_status_extra = ''\n   235\t        if self.config is None:\n   236\t            self.config_status = CONFIG_NEW\n   237\t        elif self.config.extensions != config.extensions:\n   238\t            self.config_status = CONFIG_EXTENSIONS_CHANGED\n   239\t            extensions = sorted(\n   240\t                set(self.config.extensions) ^ set(config.extensions))\n   241\t            if len(extensions) == 1:\n   242\t                extension = extensions[0]\n   243\t            else:\n   244\t                extension = '%d' % (len(extensions),)\n   245\t            self.config_status_extra = ' (%r)' % (extension,)\n   246\t        else:\n   247\t            # check if a config value was changed that affects how\n   248\t            # doctrees are read\n   249\t            for item in config.filter('env'):\n   250\t                if self.config[item.name] != item.value:\n   251\t                    self.config_status = CONFIG_CHANGED\n   252\t                    self.config_status_extra = ' (%r)' % (item.name,)\n   253\t                    break\n   254\t\n   255\t        self.config = config\n   256\t\n   257\t    def _update_settings(self, config: Config) -> None:\n   258\t        \"\"\"Update settings by new config.\"\"\"\n   259\t        self.settings['input_encoding'] = config.source_encoding\n   260\t        self.settings['trim_footnote_reference_space'] = config.trim_footnote_reference_space\n",
      "perturbed": "1\t\"\"\"\n3\t    ~~~~~~~~~~~~~~~~~~\n4\n6\n8\t    :license: BSD, see LICENSE for details.\n9\t\"\"\"\n11\timport os\n14\tfrom collections import defa...\n15\tfrom copy import copy\n16\tfrom os import path\n17\tfrom typing import Any, Callable, Dict, Generator, Iterator, Li...\n18\tfrom typing import cast\n20\tfrom docutils import nodes\n21\tfrom docutils.nodes import Node\n24\tfrom sphinx.config import Config\n27\tfrom sphinx.environment.adapters.toctree import TocTree\n25\tfrom sphinx.deprecation import RemovedInSphinx40W...\n28\tfrom sphinx.errors import SphinxError, BuildEnvironmentError, DocumentError, ExtensionError\n29\tfrom sphinx.events import EventManager\n31\tfrom sphinx.project import Project\n32\tfrom sphinx.transforms import SphinxTransformer\n33\tfrom sphinx.util import DownloadFiles, FilenameUniqDict\n36\tfrom sphinx.util.i18n import CatalogRepository, docname_to_domain\n37\tfrom sphinx.util.nodes import is_translatable\n38\n39\tif False:\n40\t    # For type annotation\n41\t    from sphinx.application import Sphinx\n43\n42\t    from sphinx.builders import Builder\n45\tlogger = logging.getLogger(__name__)\n47\tdefault_settings = {\n48\t    'embed_stylesheet': False,\n52\t    'rfc_base_url': 'https://tools.ietf.o...\n49\t    'cloak_email_add...\n53\t    'rfc_references': None,\n54\t    'input_encoding': 'utf-8-sig',\n57\t    'halt_level': 5,\n62\t# This is increased every time an environment attribute is added\n61\n65\n64\tENV_VERSION = 56\n67\tCONFIG_OK = 1\n66\t# config status\n68\tCONFIG_NEW = 2\n69\tCONFIG_CHANGED = 3\n73\t    CONFIG_NEW: __('new config'),\n70\tCONFIG_EXTENSIONS_CHANGED = 4\n76\t}\n77\n79\tversioning_conditions = {\n82\t}  # type: Dict[str, Union[bool, Callable]]\n80\t    'none': False,\n84\n86\t    \"\"\"\n87\t    The environment in which the ReST file...\n90\t    \"\"\"\n88\t    Stores an inventory of cross-file targets and provides doctree\n91\n93\n92\t    domains = None  # type: Dict[str, Domain]\n94\t    # --------- ENVIRONMENT INITIALIZATION -------------------------------------\n95\n96\t    def __init__(self, app: \"Sphinx\" = None):\n99\t        self.srcdir = None               # type: str\n97\t        self.app = None                  # type: Sphinx\n100\t        self.config = None               # type: Config\n101\t        self.config_status = None        # type: int\n104\t        self.project = None              # type: Project\n103\t        self.events = None               # type: EventManager\n105\t        self.version = None              # type: Dict[str, str]\n106\n108\t        self.versioning_condition = ...\n109\t        self.versioning_compare = None  # type: bool\n110\n112\t        self.domains = {}\n111\t        # all the registered domai...\n114\t        # the docutils settings for building\n113\n116\t        self.settings['env'] = self\n117\n118\t        # All \"docnames\" here are /-separated and re...\n119\t        # the source suffix.\n122\t                   ...\n125\t                                    # docname -> set of dependent file\n124\t        self.dependencies = defaultdict(set)    # type: Dict[str, Set[str]]\n126\t                                    # names, relative to documentation root\n129\t                                    # docnames i...\n127\t        self.included = defaultdict(set)        # type: Dict[str, Set[str]]\n130\t        self.reread_always = set()  # type: Set[str]\n133\n131\t                                    # docnames to re-read unconditionally on\n134\t        # File metadata\n136\t                                                # docname -> dict of metadata items\n135\t        self.metadata = defaultdict(dict)       # type: Dict[str, Dict[str, Any]]\n138\t        # TOC inventory\n137\n139\t        self.titles = {}            # type: Dict[str, nodes.title]\n140\t                                    # docname -> title node\n141\t        self.longtitles = {}        # type: Dict[str, nodes.title]\n142\t                                    # docname -> title node; only different if\n144\t        self.tocs = {}              # type: Dict[str, nodes.bullet_list]\n145\t                                    # docname -> table of contents nodetree\n147\t                                    # docname -> number of real entries\n149\t        # used to determine when to show the TOC\n148\n150\t        # in a sidebar (don't show if it's only one item)\n151\t        self.toc_secnumbers = {}    # type: Dict[str, Dict[str, Tuple[int, ...]]]\n152\t                                    # docname -> dict of sectionid -> number\n155\t                                    # dict of figureid -> number\n154\t                                    # docname -> dict of figtype ->\n158\t                      ...\n156\n160\t                                    # docname -> set of files\n161\t                                    # (containing its TOCs) to rebuild too\n162\t        self.glob_toctrees = set()  # type: Set[str]\n163\t                                    # docnames that have :glob: toctrees\n164\t        self.numbered_toctrees = set()  # type: Set[str]\n165\t                                        # docnames that have :numbered: toctrees\n166\n168\t        self.domaindata = {}        # type: Dict[str, Dict]\n169\t                                    # domainname -> domain-specific dict\n170\n172\t        self.images = ...\n171\t        # these map absolute path -> (docnames, unique filename)\n173\t        self.dlfil...\n175\n177\t        self.original_image_uri = {}  # type: Dict[str, str]\n178\n179\t        # temporary data storage while reading a document\n181\t        # context for cross-references (e.g. current module or class)\n182\t        # this is similar to temp_data, but will for example be copied to\n183\t        # attributes of \"any\" cross references\n185\n186\t        # set up environment\n187\t        if app:\n188\t            self.setup(app)\n191\t        \"\"\"Obtains serializable data for pickling.\"\"\"\n189\n192\t        __dict__ = self.__dict__.copy()\n194\t        return __dict__\n195\n198\n199\t    def setup(self, app: \"Sphinx\") -> None:\n201\t        if self.version and self.version != app.registry.get_envversion(app):\n200\t        \"\"\"Set up BuildEnvironment object.\"\"\"\n202\t            raise BuildEnvironmentError(__('build environment version not current'))\n207\t            app.project.restore(self.project)\n205\n209\t        self.app = app\n210\t        self.doctreedir = app.doctreedir\n212\t        self.srcdir = app.srcdir\n211\t        self.events = app.events\n213\t        self.project = app.project\n215\n214\t        self.version = app.registry.get_envver...\n217\t        self.domains = {}\n219\t            self.domains[domain.name] = domain\n222\t        for domain in self.domains.values():\n221\t        # setup domains (must do after all initialization)\n223\t            domain.setup()\n224\n225\t        # initialize config\n227\n232\t        \"\"\"Update configurations by new one.\"\"\"\n229\t        self._update_settings(app.config)\n234\t        self.config_status_extra = ''\n235\t        if self.config is None:\n236\t            self.config_...\n237\t        elif self.config.ext...\n244\t                extension = '%d' % (len(extensions),)\n243\t            else:\n245\t            self.config_status_extra = ' (%r)' % (extension,)\n246\t        else:\n248\t            # doctrees are read\n247\t            # check if a config value was changed that affects how\n249\t            for item in config.filter('env'):\n251\t                    self.config_status = CONFIG_CHANGED\n252\t                    self.config_status_extra = ' (%r)' % (item.name,)\n253\t                    break\n254\n256\n255\t        self.config = config\n257\t    def _update_settings(self, config: Config) -> None:\n258\t        \"\"\"Update settings by new config.\"\"\"\n260\t        self.settings['trim_footnote_reference_space'] = config.trim_footnote_reference_space",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "grep -RIn \"relfn2path\\\\|path2doc\\\\|docname2path\\\\|relpath\" -n sphinx | sed -n '1,200p'",
      "original": "sphinx/builders/__init__.py:31:from sphinx.util.osutil import SEP, ensuredir, relative_uri, relpath\nsphinx/builders/__init__.py:216:        def cat2relpath(cat: CatalogInfo) -> str:\nsphinx/builders/__init__.py:217:            return relpath(cat.mo_path, self.env.srcdir).replace(path.sep, SEP)\nsphinx/builders/__init__.py:222:                                       stringify_func=cat2relpath):\nsphinx/builders/__init__.py:233:            docname = self.env.path2doc(path.abspath(fpath))\nsphinx/builders/latex/transforms.py:94:                return self.env.path2doc(node['source'])\nsphinx/builders/gettext.py:33:from sphinx.util.osutil import ensuredir, canon_path, relpath\nsphinx/builders/gettext.py:127:        def _relpath(s: str) -> str:\nsphinx/builders/gettext.py:128:            return canon_path(relpath(s, self.outdir))\nsphinx/builders/gettext.py:130:        context['relpath'] = _relpath\nsphinx/builders/html/__init__.py:713:        def to_relpath(f: str) -> str:\nsphinx/builders/html/__init__.py:721:                                       stringify_func=to_relpath):\nsphinx/testing/util.py:28:from sphinx.util.osutil import relpath\nsphinx/testing/util.py:194:            yield relpath(fpath, root)\nsphinx/application.py:52:from sphinx.util.osutil import abspath, ensuredir, relpath\nsphinx/application.py:374:                    'outdir': relpath(self.outdir),\nsphinx/templates/gettext/message.pot_t:21:#: {{ relpath(source) }}:{{ line }}\nsphinx/environment/__init__.py:317:    def path2doc(self, filename: str) -> str:\nsphinx/environment/__init__.py:322:        return self.project.path2doc(filename)\nsphinx/environment/__init__.py:347:    def relfn2path(self, filename: str, docname: str = None) -> Tuple[str, str]:\nsphinx/environment/__init__.py:500:        self.included[self.docname].add(self.path2doc(filename))\nsphinx/environment/collectors/dependencies.py:48:            relpath = relative_path(frompath,\nsphinx/environment/collectors/dependencies.py:50:            app.env.dependencies[app.env.docname].add(relpath)\nsphinx/environment/collectors/asset.py:61:            rel_imgpath, full_imgpath = app.env.relfn2path(imguri, docname)\nsphinx/environment/collectors/asset.py:75:                    _, full_i18n_imgpath = app.env.relfn2path(i18n_imguri, docname)\nsphinx/environment/collectors/asset.py:129:                rel_filename, filename = app.env.relfn2path(targetname, app.env.docname)\nsphinx/project.py:19:from sphinx.util.osutil import SEP, relpath\nsphinx/project.py:57:            docname = self.path2doc(filename)\nsphinx/project.py:61:                    files = [relpath(f, self.srcdir) for f in glob(pattern)]\nsphinx/project.py:72:    def path2doc(self, filename):\nsphinx/project.py:79:            filename = relpath(filename, self.srcdir)\nsphinx/pycode/__init__.py:102:        eggpath, relpath = re.split('(?<=\\\\.egg)' + SEP, filename)\nsphinx/pycode/__init__.py:105:                code = egg.read(relpath).decode()\nsphinx/directives/other.py:358:        rel_filename, filename = self.env.relfn2path(self.arguments[0])\nsphinx/directives/code.py:425:            _, path = self.env.relfn2path(self.options['diff'])\nsphinx/directives/code.py:430:            rel_filename, filename = self.env.relfn2path(self.arguments[0])\nsphinx/util/osutil.py:146:def relpath(path: str, start: str = os.curdir) -> str:\nsphinx/util/osutil.py:150:    This is an alternative of ``os.path.relpath()``.  This returns original path\nsphinx/util/osutil.py:154:        return os.path.relpath(path, start)\nsphinx/util/osutil.py:159:safe_relpath = relpath  # for compatibility\nsphinx/util/i18n.py:28:from sphinx.util.osutil import SEP, canon_path, relpath\nsphinx/util/i18n.py:111:                        yield basedir, relpath(fullpath, basedir)\nsphinx/util/i18n.py:149:    files = [relpath(f, srcdir) for f in files if f]\nsphinx/util/i18n.py:189:                if excluded(path.join(relpath(dirpath, base_dir), filename)):\nsphinx/util/i18n.py:192:                domain = relpath(path.join(dirpath, base), base_dir).replace(path.sep, SEP)\nsphinx/ext/doctest.py:34:from sphinx.util.osutil import relpath\nsphinx/ext/doctest.py:362:            filename = relpath(node.source, self.env.srcdir)\\\nsphinx/ext/graphviz.py:134:            rel_filename, filename = self.env.relfn2path(argument)\n",
      "perturbed": "sphinx/builders/__init__.py:31:from sphinx.util.osutil import SEP, ensuredir, relative_uri, relpath\nsphinx/builders/__init__.py:217:            return relpath(cat.mo_path, self.env.srcdir).replace(path.sep, SEP)\nsphinx/builders/gettext.py:127:        def _relpath(s: str) -> str:\nsphinx/builders/gettext.py:33:from sphinx.util.osutil import ensuredir, canon_path, relpath\nsphinx/builders/html/__init__.py:713:        def to_relpath(f: str) -> str:\nsphinx/builders/gettext.py:130:        context['relpath'] = _relpath\nsphinx/builders/html/__init__.py:721:                                       stringify_func=to_relpath):\nsphinx/testing/util.py:28:from sphinx.util.osutil import relpath\nsphinx/testing/util.py:194:            yield relpath(fpath, root)\nsphinx/application.py:52:from sphinx.util.osutil import abspath...\nsphinx/application.py:374:                    'outdir': relpath(self.outdir),\nsphinx/environment/__init__.py:317:    def path2doc(self, filename: str) -> str:\nsphinx/environment/collectors/dependencies.py:48:            relpath = relative_path(frompath,\nsphinx/environment/collectors/dependencies.py:50:            app.env.dependencies[app.env.docname].add(relpath)\nsphinx/environment/collectors/asset.py:129:                rel_filename, filename = app.env.relfn2path(targetname, app.env.docname)\nsphinx/environment/collectors/asset.py:75:                    _, full_i18n_imgpath = app.env.relfn2path(i18n_imguri, docname)\nsphinx/project.py:19:from sphinx.util.osutil import SEP, relpath\nsphinx/project.py:72:    def path2doc(self, filename):\nsphinx/pycode/__init__.py:105:                code = egg.read(relpath).decode()\nsphinx/directives/other.py:358:        rel_filename, filename = self.env.relfn2path(self.arguments[0])\nsphinx/directives/code.py:425:            _, path = self.env.relfn2path(self.options['diff'])\nsphinx/util/osutil.py:14...\nsphinx/util/osutil.py:150:    This is an alternative of ``os.path.relpath()``.  This returns original path\nsphinx/util/osutil.py:154:        return os.path.relpath(path, start)\nsphinx/util/i18n.py:28:from sphinx.util.osutil import SEP, canon_path, relpath\nsphinx/util/i18n.py:149:    files = [relpath(f, srcdir) for f in files if f]\nsphinx/util/i18n.py:189:                if excluded(path.join(relpath(dirpath, ...\nsphinx/ext/doctest.py:34:from sphinx.util.osutil import relpath\nsphinx/ext/doctest.py:362:            filename = relpath(node.source, self.env.srcdir)\\\nsphinx/ext/graphviz.py:134:            rel_filename, filename = self.env.relfn2path(argument)",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "grep -RIn \"labels\\\\[\\\\|anonlabels\\\\|anonlabels\" sphinx | sed -n '1,200p'",
      "original": "sphinx/writers/html.py:275:            node.insert(0, nodes.title(name, admonitionlabels[name]))\nsphinx/writers/manpage.py:120:            self.language.labels[label] = self.deunicode(translation)  # type: ignore\nsphinx/writers/text.py:917:        label = admonitionlabels[node.tagname]\nsphinx/writers/html5.py:247:            node.insert(0, nodes.title(name, admonitionlabels[name]))\nsphinx/writers/texinfo.py:1088:        label = admonitionlabels[node.tagname]\nsphinx/writers/texinfo.py:1344:                         admonitionlabels['seealso'])\nsphinx/writers/latex.py:821:        self.body.append('\\n\\n\\\\sphinxstrong{%s:}\\n\\n' % admonitionlabels['seealso'])\nsphinx/writers/latex.py:1366:        label = admonitionlabels[node.tagname]\nsphinx/texinputs/sphinx.sty:418:\\newcommand\\sphinxsetlistlabels[5]\nsphinx/ext/autosectionlabel.py:54:                           name, app.env.doc2path(domain.labels[name][0]),\nsphinx/ext/autosectionlabel.py:57:        domain.anonlabels[name] = docname, labelid\nsphinx/ext/autosectionlabel.py:58:        domain.labels[name] = docname, labelid, sectname\nsphinx/domains/changeset.py:64:        text = versionlabels[self.name] % self.arguments[0]\nsphinx/domains/std.py:590:        'anonlabels': {         # labelname -> docname, labelid\nsphinx/domains/std.py:637:        if name in self.anonlabels and self.anonlabels[name] != (docname, node_id):\nsphinx/domains/std.py:639:                           name, self.env.doc2path(self.anonlabels[name][0]))\nsphinx/domains/std.py:641:        self.anonlabels[name] = (docname, node_id)\nsphinx/domains/std.py:643:            self.labels[name] = (docname, node_id, title)\nsphinx/domains/std.py:675:    def anonlabels(self) -> Dict[str, Tuple[str, str]]:\nsphinx/domains/std.py:676:        return self.data.setdefault('anonlabels', {})  # labelname -> docname, labelid\nsphinx/domains/std.py:688:                del self.labels[key]\nsphinx/domains/std.py:689:        for key, (fn, _l) in list(self.anonlabels.items()):\nsphinx/domains/std.py:691:                del self.anonlabels[key]\nsphinx/domains/std.py:703:                self.labels[key] = data\nsphinx/domains/std.py:704:        for key, data in otherdata['anonlabels'].items():\nsphinx/domains/std.py:706:                self.anonlabels[key] = data\nsphinx/domains/std.py:728:                               name, env.doc2path(self.labels[name][0]),\nsphinx/domains/std.py:730:            self.anonlabels[name] = docname, labelid\nsphinx/domains/std.py:745:            self.labels[name] = docname, labelid, sectname\nsphinx/domains/std.py:805:            docname, labelid = self.anonlabels.get(target, ('', ''))\nsphinx/domains/std.py:823:            docname, labelid = self.anonlabels.get(target, ('', ''))\nsphinx/domains/std.py:1005:        for name, (docname, labelid) in self.anonlabels.items():\n",
      "perturbed": "sphinx/writers/html.py:275:            node.insert(0, nodes.title(name, admonitionlabels[name]))\nsphinx/writers/text.py:917:        label = admonitionlabels[node.tagname]\nsphinx/writers/html5.py:247:            node.insert(0, nodes.title(name, admonitionlabels[name]))\nsphinx/writers/texinfo.py:1088:        label = admonitionl...\nsphinx/writers/texinfo.py:1344:                         admonitionlabels['seealso'])\nsphinx/writers/latex.py:1366:    ...\nsphinx/writers/latex.py:821:        self.body.append('\\n\\n\\\\sphinxstrong{%s:}\\n\\n' % admonitionlabels['seealso'])\nsphinx/texinputs/sphinx.sty:418:\\newcommand\\sphinxsetlistlabels[5]\nsphinx/ext/autosectionlabel.py:57:        domain.anonlabels[name] = docname, labelid\nsphinx/domains/std.py:637:        if name in self.anonlabels and self.anonlabels[name] != (docname, node_id):\nsphinx/ext/autosectionlabel.py:58:        domain.labels[name] = docname, labelid, sectname\nsphinx/domains/std.py:639:                           name, self.env.doc2pat...\nsphinx/domains/std.py:641:        self.anonlabels[name] = (docname, node_id)\nsphinx/domains/std.py:676:        return self.data.setdefault('anonlabels', {})  # labelname -> docname, labelid\nsphinx/domains/std.py:675:    def anonlabels(self) -> Dict[str, Tuple[str, str]]:\nsphinx/domains/std.py:689:        for key, (fn, _l) in list(self.anonlabels.items()):\nsphinx/domains/std.py:688:                del self.labels[key]\nsphinx/domains/std.py:691:                del self.anonlabels[key]\nsphinx/domains/std.py:704:        for key, data in otherdata['anonlabels'].items():\nsphinx/domains/std.py:706:                self.anonlabels[key] = data\nsphinx/domains/std.py:730:            self.anonlabels[name] = docname, labelid\nsphinx/domains/std.py:728:                               name, env.doc2path(self.labels[name][0]),\nsphinx/domains/std.py:745:            self.labels[name] = docname, labelid, sectname\nsphinx/domains/std.p...\nsphinx/domains/std.py:1005:        for name, (docname, labelid) in self.anonlabels.items():",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba sphinx/environment/__init__.py | sed -n '336,420p'",
      "original": "   336\t            warnings.warn('The string style base argument for doc2path() is deprecated.',\n   337\t                          RemovedInSphinx40Warning, stacklevel=2)\n   338\t\n   339\t        pathname = self.project.doc2path(docname, base is True)\n   340\t        if suffix:\n   341\t            filename, _ = path.splitext(pathname)\n   342\t            pathname = filename + suffix\n   343\t        if base and base is not True:\n   344\t            pathname = path.join(base, pathname)  # type: ignore\n   345\t        return pathname\n   346\t\n   347\t    def relfn2path(self, filename: str, docname: str = None) -> Tuple[str, str]:\n   348\t        \"\"\"Return paths to a file referenced from a document, relative to\n   349\t        documentation root and absolute.\n   350\t\n   351\t        In the input \"filename\", absolute filenames are taken as relative to the\n   352\t        source dir, while relative filenames are relative to the dir of the\n   353\t        containing document.\n   354\t        \"\"\"\n   355\t        if filename.startswith('/') or filename.startswith(os.sep):\n   356\t            rel_fn = filename[1:]\n   357\t        else:\n   358\t            docdir = path.dirname(self.doc2path(docname or self.docname,\n   359\t                                                base=None))\n   360\t            rel_fn = path.join(docdir, filename)\n   361\t        # the path.abspath() might seem redundant, but otherwise artifacts\n   362\t        # such as \"..\" will remain in the path\n   363\t        return rel_fn, path.abspath(path.join(self.srcdir, rel_fn))\n   364\t\n   365\t    @property\n   366\t    def found_docs(self) -> Set[str]:\n   367\t        \"\"\"contains all existing docnames.\"\"\"\n   368\t        return self.project.docnames\n   369\t\n   370\t    def find_files(self, config: Config, builder: \"Builder\") -> None:\n   371\t        \"\"\"Find all source files in the source dir and put them in\n   372\t        self.found_docs.\n   373\t        \"\"\"\n   374\t        try:\n   375\t            exclude_paths = (self.config.exclude_patterns +\n   376\t                             self.config.templates_path +\n   377\t                             builder.get_asset_paths())\n   378\t            self.project.discover(exclude_paths)\n   379\t\n   380\t            # Current implementation is applying translated messages in the reading\n   381\t            # phase.Therefore, in order to apply the updated message catalog, it is\n   382\t            # necessary to re-process from the reading phase. Here, if dependency\n   383\t            # is set for the doc source and the mo file, it is processed again from\n   384\t            # the reading phase when mo is updated. In the future, we would like to\n   385\t            # move i18n process into the writing phase, and remove these lines.\n   386\t            if builder.use_message_catalog:\n   387\t                # add catalog mo file dependency\n   388\t                repo = CatalogRepository(self.srcdir, self.config.locale_dirs,\n   389\t                                         self.config.language, self.config.source_encoding)\n   390\t                mo_paths = {c.domain: c.mo_path for c in repo.catalogs}\n   391\t                for docname in self.found_docs:\n   392\t                    domain = docname_to_domain(docname, self.config.gettext_compact)\n   393\t                    if domain in mo_paths:\n   394\t                        self.dependencies[docname].add(mo_paths[domain])\n   395\t        except OSError as exc:\n   396\t            raise DocumentError(__('Failed to scan documents in %s: %r') %\n   397\t                                (self.srcdir, exc)) from exc\n   398\t\n   399\t    def get_outdated_files(self, config_changed: bool) -> Tuple[Set[str], Set[str], Set[str]]:\n   400\t        \"\"\"Return (added, changed, removed) sets.\"\"\"\n   401\t        # clear all files no longer present\n   402\t        removed = set(self.all_docs) - self.found_docs\n   403\t\n   404\t        added = set()  # type: Set[str]\n   405\t        changed = set()  # type: Set[str]\n   406\t\n   407\t        if config_changed:\n   408\t            # config values affect e.g. substitutions\n   409\t            added = self.found_docs\n   410\t        else:\n   411\t            for docname in self.found_docs:\n   412\t                if docname not in self.all_docs:\n   413\t                    added.add(docname)\n   414\t                    continue\n   415\t                # if the doctree file is not there, rebuild\n   416\t                filename = path.join(self.doctreedir, docname + '.doctree')\n   417\t                if not path.isfile(filename):\n   418\t                    changed.add(docname)\n   419\t                    continue\n   420\t                # check the \"reread always\" list\n",
      "perturbed": "336\t            warnings.warn('The string style base argument for doc2path() is deprecated.',\n340\t        if suffix:\n339\t        pathname = self.project.doc2path(docname, base is True)\n341\t            filename, _ = path.splitext(pathname)\n343\t        if base and base is not True:\n342\t            pathn...\n346\n349\t        documentation root and absolute.\n348\t        \"\"\"Return paths to a file referenced from a document, relative to\n351\t        In the input \"filename\", absolute filenames are taken as relative to the\n350\n353\t        containing document.\n352\t        source dir, while relative filenames are relative to the dir of the\n355\t        if filename.startswith('/...\n357\t        else:\n356\t            rel_fn = filename[1:]\n358\t            docdir = path.dirname(self.doc2path(docname or self.docname,\n359\t                                                base=None))\n360\t            rel_fn = path.join(docdir, filename)\n361\t        # the path.abspath() might seem redundant, but otherwise artifacts\n362\t        # such as \"..\" will remain in the path\n364\n367\t        \"\"\"contains all existing docn...\n370\t    def find_files(self, config: Config, builder: \"Builder\") -> None:\n368\t        return self.pr...\n371\t        \"\"\"Find all source files in the source dir and put them in\n372\t        self.found_docs.\n373\t        \"\"\"\n375\t            exclude_paths = (self.config.exclude_patterns +\n374\t        try:\n376\t                             self.config.templates_path +\n378\t            se...\n380\t            # Current implementation is applying translated messages in the reading\n379\n381\t            # phase.Therefore, in order to apply the updated message catalog, it is\n382\t            # necessary to re-process from the reading phase. Here, if dependency\n383\t            # is set for the doc source and the mo file, it is processed again from\n384\t            # the reading phase when mo i...\n385\t            # move i18n process into the writing phase, and remove these lines.\n386\t            if builder.use_message_catalog:\n388\t                repo = CatalogRepository(self.srcdir, self.config.locale_dirs,\n387\t                # add catalog mo file dependency\n390\t                mo_paths = {c.domain: c.mo_path for c in repo.catalogs}\n389\t                                ...\n391\t                for docname in self.found_docs:\n392\t                    domain = docname_to_domain(docname, self.config.gettext_compact)\n393\t                    if domain in mo_paths:\n394\t                        self.dependencies[docname].add(mo_paths[domain])\n396\t            raise DocumentError(__('Failed to scan documents in %s: %r') %\n395\t        except OSError as exc:\n397\t                                (self.srcdir, exc)) from exc\n398\n401\t        # clear all files no longer present\n404\t        added = set()  # type: Set[str]\n402\t        removed = set(self.all_docs) - self.found_docs\n405\t        changed = set(...\n406\n408\t            # config values affect e.g. substitutions\n410\t        else:\n411\t            for docname in self.found_docs:\n412\t                if docname not in self.all_docs:\n413\t                    added.add(docname)\n415\t                # if the doctree file is not there, rebuild\n416\t                filename = path.join(self.doctreedir, docname + '.doctree')\n418\t                    changed.add(docname)\n417\t                if not path.isfile(filename):\n419\t                    continue\n420\t                # check the \"reread always\" list",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba sphinx/environment/__init__.py | sed -n '336,380p'",
      "original": "   336\t            warnings.warn('The string style base argument for doc2path() is deprecated.',\n   337\t                          RemovedInSphinx40Warning, stacklevel=2)\n   338\t\n   339\t        pathname = self.project.doc2path(docname, base is True)\n   340\t        if suffix:\n   341\t            filename, _ = path.splitext(pathname)\n   342\t            pathname = filename + suffix\n   343\t        if base and base is not True:\n   344\t            pathname = path.join(base, pathname)  # type: ignore\n   345\t        return pathname\n   346\t\n   347\t    def relfn2path(self, filename: str, docname: str = None) -> Tuple[str, str]:\n   348\t        \"\"\"Return paths to a file referenced from a document, relative to\n   349\t        documentation root and absolute.\n   350\t\n   351\t        In the input \"filename\", absolute filenames are taken as relative to the\n   352\t        source dir, while relative filenames are relative to the dir of the\n   353\t        containing document.\n   354\t        \"\"\"\n   355\t        if filename.startswith('/') or filename.startswith(os.sep):\n   356\t            rel_fn = filename[1:]\n   357\t        else:\n   358\t            docdir = path.dirname(self.doc2path(docname or self.docname,\n   359\t                                                base=None))\n   360\t            rel_fn = path.join(docdir, filename)\n   361\t        # the path.abspath() might seem redundant, but otherwise artifacts\n   362\t        # such as \"..\" will remain in the path\n   363\t        return rel_fn, path.abspath(path.join(self.srcdir, rel_fn))\n   364\t\n   365\t    @property\n   366\t    def found_docs(self) -> Set[str]:\n   367\t        \"\"\"contains all existing docnames.\"\"\"\n   368\t        return self.project.docnames\n   369\t\n   370\t    def find_files(self, config: Config, builder: \"Builder\") -> None:\n   371\t        \"\"\"Find all source files in the source dir and put them in\n   372\t        self.found_docs.\n   373\t        \"\"\"\n   374\t        try:\n   375\t            exclude_paths = (self.config.exclude_patterns +\n   376\t                             self.config.templates_path +\n   377\t                             builder.get_asset_paths())\n   378\t            self.project.discover(exclude_paths)\n   379\t\n   380\t            # Current implementation is applying translated messages in the reading\n",
      "perturbed": "336\t            warnings.warn('The string style base argument for doc2path() is deprecated.',\n337\t                          RemovedInSphinx40Warning, stacklevel=2)\n338\n340\t        if suffix:\n339\t        pathname = self.project.doc2path(docname, base is True)\n341\t            filename, _ = path.sp...\n342\t            pathname = filename + suffix\n344\t            pathname = path.join(base, pathname)  # type: ignore\n343\t        if base and base is not True:\n346\n348\t        \"\"\"Return paths to a file referenced from a document, relative to\n347\t    def relfn2path(se...\n350\n351\t        In the...\n352\t        source dir, while relative filenames are relative to the dir of the\n353\t        containing document.\n354\t        \"\"\"\n359\t                                                base=None))\n358\t            docdir = path.dirname(self.doc2path(docname or self.docname,\n360\t            rel_fn = path.join(docdir, filename)\n364\n365\t    @property\n369\n371\t        \"\"\"Find all source files in the sour...\n370\t    def find_files(self, config: Config, builder: \"Builder\") -> None:\n375\t            exclude_paths = (self.config.exclude_patterns +\n372\t        self.found_docs.\n376\t                             self.config.templates_path +\n380\t            # Current implementation is applying translated messages in the reading\n379",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba sphinx/environment/__init__.py | sed -n '344,360p'",
      "original": "   344\t            pathname = path.join(base, pathname)  # type: ignore\n   345\t        return pathname\n   346\t\n   347\t    def relfn2path(self, filename: str, docname: str = None) -> Tuple[str, str]:\n   348\t        \"\"\"Return paths to a file referenced from a document, relative to\n   349\t        documentation root and absolute.\n   350\t\n   351\t        In the input \"filename\", absolute filenames are taken as relative to the\n   352\t        source dir, while relative filenames are relative to the dir of the\n   353\t        containing document.\n   354\t        \"\"\"\n   355\t        if filename.startswith('/') or filename.startswith(os.sep):\n   356\t            rel_fn = filename[1:]\n   357\t        else:\n   358\t            docdir = path.dirname(self.doc2path(docname or self.docname,\n   359\t                                                base=None))\n   360\t            rel_fn = path.join(docdir, filename)\n",
      "perturbed": "[info] processing...\n346\n344\t            pathname = path.join(base, pathname)  # type: ignore\n347\t    def relfn2path(self, filename: str, docna...\n348\t        \"\"\"Return paths to a fi...\n349\t        documentation root a...\n350\n352\t        source dir, while relative filenames are relative to the dir of the\n355\t        if filename.startswith('/') or filename.startswith(os.sep):\n** output may be incomplete **\n356\t            rel_fn = filename[1:]\n357\t        else:\n358\t            docdir = path.dirname(self.doc2path(docname or self.docname,\n360\t            rel_fn = path.join(docd...\n359\t                                                base=None))",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba sphinx/domains/std.py | sed -n '1,260p'",
      "original": "     1\t\"\"\"\n     2\t    sphinx.domains.std\n     3\t    ~~~~~~~~~~~~~~~~~~\n     4\t\n     5\t    The standard domain.\n     6\t\n     7\t    :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n     8\t    :license: BSD, see LICENSE for details.\n     9\t\"\"\"\n    10\t\n    11\timport re\n    12\timport unicodedata\n    13\timport warnings\n    14\tfrom copy import copy\n    15\tfrom typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Tuple, Union\n    16\tfrom typing import cast\n    17\t\n    18\tfrom docutils import nodes\n    19\tfrom docutils.nodes import Element, Node, system_message\n    20\tfrom docutils.parsers.rst import Directive, directives\n    21\tfrom docutils.statemachine import StringList\n    22\t\n    23\tfrom sphinx import addnodes\n    24\tfrom sphinx.addnodes import desc_signature, pending_xref\n    25\tfrom sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning\n    26\tfrom sphinx.directives import ObjectDescription\n    27\tfrom sphinx.domains import Domain, ObjType\n    28\tfrom sphinx.locale import _, __\n    29\tfrom sphinx.roles import XRefRole\n    30\tfrom sphinx.util import ws_re, logging, docname_join\n    31\tfrom sphinx.util.docutils import SphinxDirective\n    32\tfrom sphinx.util.nodes import clean_astext, make_id, make_refnode\n    33\tfrom sphinx.util.typing import RoleFunction\n    34\t\n    35\tif False:\n    36\t    # For type annotation\n    37\t    from typing import Type  # for python3.5.1\n    38\t    from sphinx.application import Sphinx\n    39\t    from sphinx.builders import Builder\n    40\t    from sphinx.environment import BuildEnvironment\n    41\t\n    42\tlogger = logging.getLogger(__name__)\n    43\t\n    44\t\n    45\t# RE for option descriptions\n    46\toption_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=[]+)(=?\\s*.*)')\n    47\t# RE for grammar tokens\n    48\ttoken_re = re.compile(r'`(\\w+)`', re.U)\n    49\t\n    50\t\n    51\tclass GenericObject(ObjectDescription):\n    52\t    \"\"\"\n    53\t    A generic x-ref directive registered with Sphinx.add_object_type().\n    54\t    \"\"\"\n    55\t    indextemplate = ''\n    56\t    parse_node = None  # type: Callable[[GenericObject, BuildEnvironment, str, desc_signature], str]  # NOQA\n    57\t\n    58\t    def handle_signature(self, sig: str, signode: desc_signature) -> str:\n    59\t        if self.parse_node:\n    60\t            name = self.parse_node(self.env, sig, signode)\n    61\t        else:\n    62\t            signode.clear()\n    63\t            signode += addnodes.desc_name(sig, sig)\n    64\t            # normalize whitespace like XRefRole does\n    65\t            name = ws_re.sub(' ', sig)\n    66\t        return name\n    67\t\n    68\t    def add_target_and_index(self, name: str, sig: str, signode: desc_signature) -> None:\n    69\t        node_id = make_id(self.env, self.state.document, self.objtype, name)\n    70\t        signode['ids'].append(node_id)\n    71\t\n    72\t        # Assign old styled node_id not to break old hyperlinks (if possible)\n    73\t        # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)\n    74\t        old_node_id = self.make_old_id(name)\n    75\t        if old_node_id not in self.state.document.ids and old_node_id not in signode['ids']:\n    76\t            signode['ids'].append(old_node_id)\n    77\t\n    78\t        self.state.document.note_explicit_target(signode)\n    79\t\n    80\t        if self.indextemplate:\n    81\t            colon = self.indextemplate.find(':')\n    82\t            if colon != -1:\n    83\t                indextype = self.indextemplate[:colon].strip()\n    84\t                indexentry = self.indextemplate[colon + 1:].strip() % (name,)\n    85\t            else:\n    86\t                indextype = 'single'\n    87\t                indexentry = self.indextemplate % (name,)\n    88\t            self.indexnode['entries'].append((indextype, indexentry, node_id, '', None))\n    89\t\n    90\t        std = cast(StandardDomain, self.env.get_domain('std'))\n    91\t        std.note_object(self.objtype, name, node_id, location=signode)\n    92\t\n    93\t    def make_old_id(self, name: str) -> str:\n    94\t        \"\"\"Generate old styled node_id for generic objects.\n    95\t\n    96\t        .. note:: Old Styled node_id was used until Sphinx-3.0.\n    97\t                  This will be removed in Sphinx-5.0.\n    98\t        \"\"\"\n    99\t        return self.objtype + '-' + name\n   100\t\n   101\t\n   102\tclass EnvVar(GenericObject):\n   103\t    indextemplate = _('environment variable; %s')\n   104\t\n   105\t\n   106\tclass EnvVarXRefRole(XRefRole):\n   107\t    \"\"\"\n   108\t    Cross-referencing role for environment variables (adds an index entry).\n   109\t    \"\"\"\n   110\t\n   111\t    def result_nodes(self, document: nodes.document, env: \"BuildEnvironment\", node: Element,\n   112\t                     is_ref: bool) -> Tuple[List[Node], List[system_message]]:\n   113\t        if not is_ref:\n   114\t            return [node], []\n   115\t        varname = node['reftarget']\n   116\t        tgtid = 'index-%s' % env.new_serialno('index')\n   117\t        indexnode = addnodes.index()\n   118\t        indexnode['entries'] = [\n   119\t            ('single', varname, tgtid, '', None),\n   120\t            ('single', _('environment variable; %s') % varname, tgtid, '', None)\n   121\t        ]\n   122\t        targetnode = nodes.target('', '', ids=[tgtid])\n   123\t        document.note_explicit_target(targetnode)\n   124\t        return [indexnode, targetnode, node], []\n   125\t\n   126\t\n   127\tclass Target(SphinxDirective):\n   128\t    \"\"\"\n   129\t    Generic target for user-defined cross-reference types.\n   130\t    \"\"\"\n   131\t    indextemplate = ''\n   132\t\n   133\t    has_content = False\n   134\t    required_arguments = 1\n   135\t    optional_arguments = 0\n   136\t    final_argument_whitespace = True\n   137\t    option_spec = {}  # type: Dict\n   138\t\n   139\t    def run(self) -> List[Node]:\n   140\t        # normalize whitespace in fullname like XRefRole does\n   141\t        fullname = ws_re.sub(' ', self.arguments[0].strip())\n   142\t        node_id = make_id(self.env, self.state.document, self.name, fullname)\n   143\t        node = nodes.target('', '', ids=[node_id])\n   144\t        self.set_source_info(node)\n   145\t\n   146\t        # Assign old styled node_id not to break old hyperlinks (if possible)\n   147\t        # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)\n   148\t        old_node_id = self.make_old_id(fullname)\n   149\t        if old_node_id not in self.state.document.ids and old_node_id not in node['ids']:\n   150\t            node['ids'].append(old_node_id)\n   151\t\n   152\t        self.state.document.note_explicit_target(node)\n   153\t        ret = [node]  # type: List[Node]\n   154\t        if self.indextemplate:\n   155\t            indexentry = self.indextemplate % (fullname,)\n   156\t            indextype = 'single'\n   157\t            colon = indexentry.find(':')\n   158\t            if colon != -1:\n   159\t                indextype = indexentry[:colon].strip()\n   160\t                indexentry = indexentry[colon + 1:].strip()\n   161\t            inode = addnodes.index(entries=[(indextype, indexentry, node_id, '', None)])\n   162\t            ret.insert(0, inode)\n   163\t        name = self.name\n   164\t        if ':' in self.name:\n   165\t            _, name = self.name.split(':', 1)\n   166\t\n   167\t        std = cast(StandardDomain, self.env.get_domain('std'))\n   168\t        std.note_object(name, fullname, node_id, location=node)\n   169\t\n   170\t        return ret\n   171\t\n   172\t    def make_old_id(self, name: str) -> str:\n   173\t        \"\"\"Generate old styled node_id for targets.\n   174\t\n   175\t        .. note:: Old Styled node_id was used until Sphinx-3.0.\n   176\t                  This will be removed in Sphinx-5.0.\n   177\t        \"\"\"\n   178\t        return self.name + '-' + name\n   179\t\n   180\t\n   181\tclass Cmdoption(ObjectDescription):\n   182\t    \"\"\"\n   183\t    Description of a command-line option (.. option).\n   184\t    \"\"\"\n   185\t\n   186\t    def handle_signature(self, sig: str, signode: desc_signature) -> str:\n   187\t        \"\"\"Transform an option description into RST nodes.\"\"\"\n   188\t        count = 0\n   189\t        firstname = ''\n   190\t        for potential_option in sig.split(', '):\n   191\t            potential_option = potential_option.strip()\n   192\t            m = option_desc_re.match(potential_option)\n   193\t            if not m:\n   194\t                logger.warning(__('Malformed option description %r, should '\n   195\t                                  'look like \"opt\", \"-opt args\", \"--opt args\", '\n   196\t                                  '\"/opt args\" or \"+opt args\"'), potential_option,\n   197\t                               location=signode)\n   198\t                continue\n   199\t            optname, args = m.groups()\n   200\t            if count:\n   201\t                signode += addnodes.desc_addname(', ', ', ')\n   202\t            signode += addnodes.desc_name(optname, optname)\n   203\t            signode += addnodes.desc_addname(args, args)\n   204\t            if not count:\n   205\t                firstname = optname\n   206\t                signode['allnames'] = [optname]\n   207\t            else:\n   208\t                signode['allnames'].append(optname)\n   209\t            count += 1\n   210\t        if not firstname:\n   211\t            raise ValueError\n   212\t        return firstname\n   213\t\n   214\t    def add_target_and_index(self, firstname: str, sig: str, signode: desc_signature) -> None:\n   215\t        currprogram = self.env.ref_context.get('std:program')\n   216\t        for optname in signode.get('allnames', []):\n   217\t            prefixes = ['cmdoption']\n   218\t            if currprogram:\n   219\t                prefixes.append(currprogram)\n   220\t            if not optname.startswith(('-', '/')):\n   221\t                prefixes.append('arg')\n   222\t            prefix = '-'.join(prefixes)\n   223\t            node_id = make_id(self.env, self.state.document, prefix, optname)\n   224\t            signode['ids'].append(node_id)\n   225\t\n   226\t        self.state.document.note_explicit_target(signode)\n   227\t\n   228\t        domain = cast(StandardDomain, self.env.get_domain('std'))\n   229\t        for optname in signode.get('allnames', []):\n   230\t            domain.add_program_option(currprogram, optname,\n   231\t                                      self.env.docname, signode['ids'][0])\n   232\t\n   233\t        # create an index entry\n   234\t        if currprogram:\n   235\t            descr = _('%s command line option') % currprogram\n   236\t        else:\n   237\t            descr = _('command line option')\n   238\t        for option in sig.split(', '):\n   239\t            entry = '; '.join([descr, option])\n   240\t            self.indexnode['entries'].append(('pair', entry, signode['ids'][0], '', None))\n   241\t\n   242\t\n   243\tclass Program(SphinxDirective):\n   244\t    \"\"\"\n   245\t    Directive to name the program for which options are documented.\n   246\t    \"\"\"\n   247\t\n   248\t    has_content = False\n   249\t    required_arguments = 1\n   250\t    optional_arguments = 0\n   251\t    final_argument_whitespace = True\n   252\t    option_spec = {}  # type: Dict\n   253\t\n   254\t    def run(self) -> List[Node]:\n   255\t        program = ws_re.sub('-', self.arguments[0].strip())\n   256\t        if program == 'None':\n   257\t            self.env.ref_context.pop('std:program', None)\n   258\t        else:\n   259\t            self.env.ref_context['std:program'] = program\n   260\t        return []\n",
      "perturbed": "2\t    sphinx.domains.std\n3\t    ~~~~~~~~~~~~~~~~~~\n5\t    The standard domain.\n4\n7\t    :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n6\n8\t    :license: BSD, see LICENSE for details.\n10\n13\timport warnings\n11\timport re\n14\tfrom copy import copy\n17\n15\tfrom typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Tuple, Union\n18\tfrom docutils import nodes\n19\tfrom docutils.nodes import Element, Node, system_message\n22\n20\tfrom docutils.parsers.rst import Directive, directives\n24\tfrom sphinx.addnodes impo...\n23\tfrom sphinx import addnodes\n27\tfrom sphinx.domains import Domain, ObjType\n25\tfrom sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning\n28\tfrom sphinx.locale import _, __\n29\tfrom sphinx.roles import XRefRole\n30\tfrom sphinx.util import ws_re, logging, docname_join\n31\tfrom sphinx.util.docutils import SphinxDirective\n34\n33\tfrom sphinx.util.typing import RoleFunction\n35\tif False:\n36\t    # For type annotation\n38\t    from sphinx.application import Sphinx\n42\tlogger = logging.getLogger(__name__)\n41\n44\n46\toption_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=[]+)(=?\\s*.*)')\n47\t# RE for grammar tokens\n48\ttoken_re = re.compile(r'`(\\w+)`', re.U)\n49\n50\n51\tclass GenericObject(ObjectDescription):\n52\t    \"\"\"\n53\t    A generic x-ref directive registered with Sphinx.add_object_type().\n55\t    indextemplate = ''\n57\n59\t        if self.parse_node:\n58\t    def handle_signature(self, sig: str, signode: desc_signature) -> str:\n60\t            name = self.parse_node(self.env, sig, signode)\n63\t            signode += addnodes.desc_name(sig, sig)\n61\t        else:\n66\t        return name\n64\t            # normalize whitespace like XRefRole does\n70\t        signode['ids'].append(node_id)\n69\t        node_id = make_id(self.env, self.state.document, self.objtype, name)\n71\n73\t        # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)\n72\t        # Assign old styled node_id not to break old hyperlinks (if possible)\n74\t        old_node_id = self.make_old_id(name)\n75\t        if old_node_id not in self.state.document.ids and old_node_id not in signode['ids']:\n76\t            signode['ids'].append(old_node_id)\n78\t        self.state.document.note_explicit_target(signode)\n79\n80\t        if self.indextemplate:\n82\t            if colon != -1:\n81\t            colon = self.indextemplate.find(':')\n83\t                indextype = self.indextemplate[:colon].strip()\n86\t               ...\n88\t            self.indexnode['entries'].append((indextype, indexentry, node_id, '', None))\n87\t                indexentry = self.indextemplate % (name,)\n89\n92\n90\t        std = cast(StandardDomain, self.env.get_domain('std'))\n93\t    def make_old_id(self, name: str) -> str:\n95\n97\t                  This will be removed in Sphinx-5.0.\n96\t        .. note:: Old Style...\n98\t        \"\"\"\n101\n102\tclass EnvVar(GenericObject):\n103\t    indextemplate = _('environment variable; %s')\n104\n106\tclass EnvVarXRefRole(XRefRole):\n107\t    \"\"\"\n108\t    Cross-referencing role for environment variables (adds an index entry).\n109\t    \"\"\"\n110\n112\t                     is_ref: bool) -> Tuple[List[Node], List[system_message]]:\n113\t        if not is_ref:\n115\t        varname =...\n116\t        tgtid = 'index-%s' % env.new_serialno('index')\n117\t        indexnode = addnodes.index()\n118\t        indexnode['entries'] = [\n119\t            ('single', varname, tgtid, '', None),\n121\t        ]\n120\t            ('single', _('environment variable; %s') % varname, tgtid, '', None)\n122\t        targetnode = nodes.target('', '', ids=[tgtid])\n123\t        document.note_explicit_target(targetnode)\n124\t        return [indexnode, targetnode, node], []\n125\n128\t    \"\"\"\n126\n129\t    Generic target for user-defined cross-reference types.\n130\t    \"\"\"\n131\t    indextemplate = ''\n136\t    final_argument_whitespace = True\n133\t    has_content = False\n137\t    option_spec = {}  # type: Dict\n140\t        # normalize whitespace in fullname like XRefRole does\n142\t        node_id = make_id(self.env, self.state.document, self.name, fullname)\n143\t        node = nodes.target('', '', ids=[node_id])\n144\t        self.set_source_info(node)\n146\t        # Assign old styled node_id not to break old hyperlinks (if possible)\n145\n148\t        old_node_id = self.make_old_id(fullname)\n149\t        if old_node_id not in self.state.document.ids and old_node_id not in node['ids']:\n150\t            node['ids'].append(old_node_id)\n153\t        ret = [node]  # t...\n152\t        self.state.document.note_explicit_target(node)\n154\t        if self.indextemplate:\n155\t            indexentry = self.indextemplate % (fullname,)\n163\t        name = self.name\n158\t            if colon != -1:\n164\t        if ':' in self.name:\n166\n165\t            _, name = self.name.split(':', 1)\n167\t        std = cast(StandardDomain, self.env.get_domain('std'))\n169\n170\t        return ret\n172\t    def make_old_id(self, name: str) -> str:\n171\n173\t        \"\"\"Generate old styled node_id for targets.\n174\n176\t                  This will be removed in Sphinx-5.0.\n175\t        .. note:: Old Styled node_id was used until Sphinx-3.0.\n177\t        \"\"\"\n179\n182\t    \"\"\"\n181\tclass Cmdoption(ObjectDescription):\n183\t    Description of a command-line option (.. option).\n184\t    \"\"\"\n186\t    def handle_signature(self, sig: str, signode: desc_signature) -> str:\n185\n187\t        \"\"\"Transform an option description into RST nodes.\"\"\"\n188\t        count = 0\n189\t        firstname = ''\n192\t            m = option_desc_re.match(potential_option)\n193\t            if not m:\n194\t                logger.warning(__('Malformed option description %r, should '\n195\t                                  'look like \"opt\", \"-opt args\", \"--opt args\", '\n196\t                                  '\"/opt args\" or \"+opt args\"'), potential_option,\n197\t                               location=signode)\n198\t                continue\n199\t            optname, args...\n204\t            if not count:\n201\t                signode += addnodes.desc_addname(', ', ', ')\n206\t                signode['allnames'] = [optname]\n205\t               ...\n207\t            else:\n208\t                signode['allnames'].append(optname)\n209\t            count += 1\n210\t        if not firstname:\n211\t            raise ValueError\n212\t        return firstname\n214\t    def add_target_and_index(sel...\n215\t        currprogram = self.env.ref_context.get('std:program')\n218\t            if currprogram:\n217\t            prefixes = ['cmdoption']\n220\t            if not optname.startswith(('-', '/')):\n219\t                prefixes.append(currprogram)\n221\t                prefixes.append('arg')\n222\t            prefix = '-'.jo...\n227\n226\t        self.state....\n229\t        for optname in signode.get('allnames', []):\n230\t            domain.add_program_option(currprogram, optname,\n231\t                                      self.env.docname, signode['ids'][0])\n232\n233\t        # create an index entry\n236\t        else:\n235\t            descr = _('%s command line option') % currprogram\n237\t            descr = _('command line option')\n238\t        for option in sig.split(...\n239\t            entry = '; '.join([descr, option])\n240\t            self.indexnode['entries'].append(('pair', entry, signode['id...\n241\n242\n243\tclass Program(SphinxDirective):\n244\t    \"\"\"\n245\t    Directive to name the program for which options are documented.\n248\t    has_content = False\n247\n249\t    required_arguments = 1\n250\t    optional_arguments = 0\n251\t    final_argument_whitespace = True\n252\t    option_spec = {}  # type: Dict\n253\n254\t    def run(self) -> List[Node]:\n256\t        if program == 'None':\n257\t            self.env.ref_context.pop('std:program', None)\n258\t        else:\n260\t        return []",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba sphinx/environment/__init__.py | sed -n '312,332p'",
      "original": "   312\t\n   313\t        for domainname, domain in self.domains.items():\n   314\t            domain.merge_domaindata(docnames, other.domaindata[domainname])\n   315\t        self.events.emit('env-merge-info', self, docnames, other)\n   316\t\n   317\t    def path2doc(self, filename: str) -> str:\n   318\t        \"\"\"Return the docname for the filename if the file is document.\n   319\t\n   320\t        *filename* should be absolute or relative to the source directory.\n   321\t        \"\"\"\n   322\t        return self.project.path2doc(filename)\n   323\t\n   324\t    def doc2path(self, docname: str, base: Union[bool, str] = True, suffix: str = None) -> str:\n   325\t        \"\"\"Return the filename for the document name.\n   326\t\n   327\t        If *base* is True, return absolute path under self.srcdir.\n   328\t        If *base* is None, return relative path to self.srcdir.\n   329\t        If *base* is a path string, return absolute path under that.\n   330\t        If *suffix* is not None, add it instead of config.source_suffix.\n   331\t        \"\"\"\n   332\t        if suffix:\n",
      "perturbed": "312\n313\t        for domainname, domain in self.domains.items():\n314\t            domain.merge_domaindata(docnames, other.domaindata[domainname])\n316\n320\t        *filename* should be absolute or relative to the source directory.\n318\t        \"\"\"Return the docname for the filename if the file is document.\n322\t        return self.project.path2doc(filename)\n324\t    def doc2path(self, docname: str, base: Union[bool, str] = True, suffix: str = None) -> str:\n323\n325\t        \"\"\"Return the filename for the document name.\n326\n328\t        If *base* is None, return relative path to self.srcdir.\n327\t        If *base* is True, return absolute path under self.srcdir.\n330\t        If *suffix* is not None, add it instead of config.source_suffix.\n331\t        \"\"\"\n332\t        if suffix:",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "grep -n \"class StandardDomain\" -n sphinx/domains/std.py || true",
      "original": "535:class StandardDomain(Domain):\n",
      "perturbed": "535:class StandardDomain(Domain):",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba sphinx/project.py | sed -n '64,116p'",
      "original": "    64\t                                   docname, files, self.doc2path(docname), once=True)\n    65\t                elif os.access(os.path.join(self.srcdir, filename), os.R_OK):\n    66\t                    self.docnames.add(docname)\n    67\t                else:\n    68\t                    logger.warning(__(\"document not readable. Ignored.\"), location=docname)\n    69\t\n    70\t        return self.docnames\n    71\t\n    72\t    def path2doc(self, filename):\n    73\t        # type: (str) -> str\n    74\t        \"\"\"Return the docname for the filename if the file is document.\n    75\t\n    76\t        *filename* should be absolute or relative to the source directory.\n    77\t        \"\"\"\n    78\t        if filename.startswith(self.srcdir):\n    79\t            filename = relpath(filename, self.srcdir)\n    80\t        for suffix in self.source_suffix:\n    81\t            if filename.endswith(suffix):\n    82\t                filename = path_stabilize(filename)\n    83\t                return filename[:-len(suffix)]\n    84\t\n    85\t        # the file does not have docname\n    86\t        return None\n    87\t\n    88\t    def doc2path(self, docname, basedir=True):\n    89\t        # type: (str, bool) -> str\n    90\t        \"\"\"Return the filename for the document name.\n    91\t\n    92\t        If *basedir* is True, return as an absolute path.\n    93\t        Else, return as a relative path to the source directory.\n    94\t        \"\"\"\n    95\t        docname = docname.replace(SEP, os.path.sep)\n    96\t        basename = os.path.join(self.srcdir, docname)\n    97\t        for suffix in self.source_suffix:\n    98\t            if os.path.isfile(basename + suffix):\n    99\t                break\n   100\t        else:\n   101\t            # document does not exist\n   102\t            suffix = list(self.source_suffix)[0]\n   103\t\n   104\t        if basedir:\n   105\t            return basename + suffix\n   106\t        else:\n   107\t            return docname + suffix\n",
      "perturbed": "64\t                                   docname, files, self.doc2path(docname), once=True)\n65\t                elif os.access(os.path.join(self.srcdir, filename), os.R_OK):\n66\t                    self.docnames.add(docname)\n68\t                    logger.warning(__(\"document not readable. Ignored.\"), location=docname)\n67\t                else:\n70\t        return self.docnames\n69\n71\n72\t    def path2doc(self, filename):\n73\t        # type: (str) -> str\n75\nnote: partial output truncated\n74\t        \"\"\"Return the docname for the filename if the file is document.\n77\t        \"\"\"\n78\t        if filename.startswith(self.srcdir):\n79\t            filenam...\n80\t        for suffix in self.source_su...\n83\t                return filename[:-len(suffix)]\n81\t            if filename.endswith(suffix):\n85\t        # the file does not have docname\n86\t        return None\n88\t    def doc2path(self, docname, basedir=True):\n89\t        # type: (str, bool) -> str\n90\t        \"\"\"Return the filename for the document name.\n91\n92\t        If *basedir* is True, return as an absolute path.\n94\t        \"\"\"\n95\t        docname = docname.replace(SEP, os.path.sep)\n96\t        basename = os.path.join(self.srcdir, docname)\n97\t        for suffix in self.source_suffix:\n99\t                break\n98\t            if os.path.isfile(basename + suffix):\n101\t            # document does not exist\n103\n104\t        if basedir:\n107\t            return docname + suffix\n105\t            return basename + suffix",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba sphinx/builders/linkcheck.py | sed -n '200,230p'",
      "original": "   200\t            else:\n   201\t                new_url = response.url\n   202\t                if anchor:\n   203\t                    new_url += '#' + anchor\n   204\t                # history contains any redirects, get last\n   205\t                if response.history:\n   206\t                    code = response.history[-1].status_code\n   207\t                    return 'redirected', new_url, code\n   208\t                else:\n   209\t                    return 'redirected', new_url, 0\n   210\t\n   211\t        def check() -> Tuple[str, str, int]:\n   212\t            # check for various conditions without bothering the network\n   213\t            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n   214\t                return 'unchecked', '', 0\n   215\t            elif not uri.startswith(('http:', 'https:')):\n   216\t                return 'local', '', 0\n   217\t            elif uri in self.good:\n   218\t                return 'working', 'old', 0\n   219\t            elif uri in self.broken:\n   220\t                return 'broken', self.broken[uri], 0\n   221\t            elif uri in self.redirected:\n   222\t                return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n   223\t            for rex in self.to_ignore:\n   224\t                if rex.match(uri):\n   225\t                    return 'ignored', '', 0\n   226\t\n   227\t            # need to actually check the URI\n   228\t            for _ in range(self.app.config.linkcheck_retries):\n   229\t                status, info, code = check_uri()\n   230\t                if status != \"broken\":\n",
      "perturbed": "200\t            else:\n202\t                if anchor:\n201\t                new_url = response.url\n203\t                    new_url += '#' + anchor\n204\t                # history contains any redirects, get last\n205\t                if response.history:\n209\t                    return 'redirected', new_url, 0\n208\t                else:\n211\t        def ch...\n210\n214\t                return ...\n218\t                return 'working', 'old', 0\n219\t            elif uri in self.broken:\n221\t            elif uri in self.redirected:\n222\t                return 'redirected', self.redirected[uri][0], self.redirected[uri][1]\n223\t            for rex in self.to_ignore:\n224\t                if rex.match(uri):\n225\t                    return 'i...\n227\t            # need to actually check the URI\n228\t            for _ in range(self.app.config.linkcheck_retries):\n229\t                status, info, code = check_uri()",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "grep -n \"return 'local'\\\\|elif not uri.startswith\" sphinx/builders/linkcheck.py || true",
      "original": "215:            elif not uri.startswith(('http:', 'https:')):\n216:                return 'local', '', 0\n",
      "perturbed": "215:            elif not uri.startswith(('http:', 'https:')):\n216:                return 'local', '', 0",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba sphinx/builders/linkcheck.py | sed -n '208,220p'",
      "original": "   208\t                else:\n   209\t                    return 'redirected', new_url, 0\n   210\t\n   211\t        def check() -> Tuple[str, str, int]:\n   212\t            # check for various conditions without bothering the network\n   213\t            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n   214\t                return 'unchecked', '', 0\n   215\t            elif not uri.startswith(('http:', 'https:')):\n   216\t                return 'local', '', 0\n   217\t            elif uri in self.good:\n   218\t                return 'working', 'old', 0\n   219\t            elif uri in self.broken:\n   220\t                return 'broken', self.broken[uri], 0\n",
      "perturbed": "211\t        def check() -> Tuple[str, str, int]:\n208\t                else:\n212\t            # check for various conditions without bothering the network\nnote: partial output truncated\n213\t            if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n214\t                return 'unchecked', '', 0\n215\t            elif not uri.startswith(('http:', 'https:')):\n216\t                return 'local', '', 0\n217\t            elif uri in self.good:\n218\t                return 'working', '...\n[warning] unexpected output\n219\t            elif uri in self.broken:",
      "applied_operators": [
        "text_perturbation"
      ]
    }
  ]
}