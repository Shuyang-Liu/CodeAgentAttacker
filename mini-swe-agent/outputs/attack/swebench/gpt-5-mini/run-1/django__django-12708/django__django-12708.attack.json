{
  "info": {
    "total_observations": 12,
    "python_observations": 2,
    "text_observations": 10,
    "ast_operators_applied": 0,
    "text_perturbation_applied": 2,
    "skipped": 10
  },
  "perturbations": [
    {
      "action": "nl -ba django/db/backends/base/schema.py | sed -n '1120,1188p'",
      "original": "  1120\t            'name': self.quote_name(name),\n  1121\t            'constraint': self.sql_check_constraint % {'check': check},\n  1122\t        }\n  1123\t\n  1124\t    def _create_check_sql(self, model, name, check):\n  1125\t        return Statement(\n  1126\t            self.sql_create_check,\n  1127\t            table=Table(model._meta.db_table, self.quote_name),\n  1128\t            name=self.quote_name(name),\n  1129\t            check=check,\n  1130\t        )\n  1131\t\n  1132\t    def _delete_check_sql(self, model, name):\n  1133\t        return self._delete_constraint_sql(self.sql_delete_check, model, name)\n  1134\t\n  1135\t    def _delete_constraint_sql(self, template, model, name):\n  1136\t        return Statement(\n  1137\t            template,\n  1138\t            table=Table(model._meta.db_table, self.quote_name),\n  1139\t            name=self.quote_name(name),\n  1140\t        )\n  1141\t\n  1142\t    def _constraint_names(self, model, column_names=None, unique=None,\n  1143\t                          primary_key=None, index=None, foreign_key=None,\n  1144\t                          check=None, type_=None, exclude=None):\n  1145\t        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n  1146\t        if column_names is not None:\n  1147\t            column_names = [\n  1148\t                self.connection.introspection.identifier_converter(name)\n  1149\t                for name in column_names\n  1150\t            ]\n  1151\t        with self.connection.cursor() as cursor:\n  1152\t            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n  1153\t        result = []\n  1154\t        for name, infodict in constraints.items():\n  1155\t            if column_names is None or column_names == infodict['columns']:\n  1156\t                if unique is not None and infodict['unique'] != unique:\n  1157\t                    continue\n  1158\t                if primary_key is not None and infodict['primary_key'] != primary_key:\n  1159\t                    continue\n  1160\t                if index is not None and infodict['index'] != index:\n  1161\t                    continue\n  1162\t                if check is not None and infodict['check'] != check:\n  1163\t                    continue\n  1164\t                if foreign_key is not None and not infodict['foreign_key']:\n  1165\t                    continue\n  1166\t                if type_ is not None and infodict['type'] != type_:\n  1167\t                    continue\n  1168\t                if not exclude or name not in exclude:\n  1169\t                    result.append(name)\n  1170\t        return result\n  1171\t\n  1172\t    def _delete_primary_key(self, model, strict=False):\n  1173\t        constraint_names = self._constraint_names(model, primary_key=True)\n  1174\t        if strict and len(constraint_names) != 1:\n  1175\t            raise ValueError('Found wrong number (%s) of PK constraints for %s' % (\n  1176\t                len(constraint_names),\n  1177\t                model._meta.db_table,\n  1178\t            ))\n  1179\t        for constraint_name in constraint_names:\n  1180\t            self.execute(self._delete_primary_key_sql(model, constraint_name))\n  1181\t\n  1182\t    def _create_primary_key_sql(self, model, field):\n  1183\t        return Statement(\n  1184\t            self.sql_create_pk,\n  1185\t            table=Table(model._meta.db_table, self.quote_name),\n  1186\t            name=self.quote_name(\n  1187\t                self._create_index_name(model._meta.db_table, [field.column], suffix=\"_pk\")\n  1188\t            ),\n",
      "perturbed": "  1121\t            'constraint': self.sql_check_constraint % {'check': check},\n  1123\t\n  1122\t        }\n  1124\t    def _create_check_sql(self, model, name, check):\n  1125\t        return Statement(\n  1127\t            table=Table(model._meta.db_table, self.quote_name),\n  1126\t            self.sql_create_check,\n  1129\t            check=check,\n  1128\t            name=self.quote_name(name),\n  1131\t\n  1130\t        )\n  1132\t    def _delete_check_sql(self, model, name):\n  1133\t        return self._delete_constraint_sql(self.sql_delete_check, model, name)\n  1134\t\n  1135\t    def _delete_constraint_sql(self, template, model, name):\n  1137\t            template,\n  1136\t        return Statement(\n  1138\t            table=Table(model._meta.db_table, self.quote_name),\n  1139\t            name=self.quote_name(name),\n  1140\t        )\n  1141\t\n  1143\t                          primary_key=None, index=None, foreign_key=None,\n  1144\t                          check=None, type_=None, exclude=None):\n  1145\t        \"\"\"Return all constraint names matching the columns and conditions.\"\"\"\n  1146\t        if column_names is not None:\n  1147\t            column_names = [\n  1148\t                self.connection.introspection.identifier_converter(name)\n  1149\t                for name in column_names\n  1150\t            ]\n  1152\t            constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n  1153\t        result = []\n  1154\t        for name, infodict in constraints.items():\n  1155\t            if column_names is None or column_names == infodict['columns']:\n  1156\t                if unique is not None and infodict['unique'] != unique:\n  1157\t                    continue\n  1158\t                if primary_key is not None and infodict['primary_key'] != primary_key:\n  1159\t                    continue\n[warning] unexpected output\n  1160\t                if index is not None and infodict['index'] != index:\n  1161\t                    continue\n  1163\t                    continue\n  1162\t                if check is not None and infodict['check'] != check:\n  1164\t                if foreign_key is not None and not infodict['foreign_key']:\n  1165\t                    continue\n  1166\t                if type_ is not None and infodict['type'] != type_:\n  1169\t                    result.append(name)\n  1170\t        return result\n  1171\t\n  1172\t    def _delete_primary_key(self, model, strict=False):\n  1173\t        constraint_names = self._constraint_names(model, primary_key=True)\n  1174\t        if strict and len(constraint_names) != 1:\n  1175\t            raise ValueError('Found wrong number (%s) of PK constraints for %s' % (\n  1176\t                len(constraint_names),\n  1177\t                model._meta.db_table,\n  1178\t            ))\n  1180\t            self.execute(self._delete_primary_key_sql(model, constraint_name))\n  1182\t    def _create_primary_key_sql(self, model, field):\n  1181\t\n  1185\t            table=Table(model._meta.db_table, self.quote_name),\n  1187\t                self._create_index_name(model._meta.db_table, [field.column], suffix=\"_pk\")\n  1186\t            name=self.quote_name(\n  1188\t            ),",
      "applied_operators": [
        "text_perturbation"
      ]
    },
    {
      "action": "nl -ba django/db/backends/base/schema.py | sed -n '432,456p'",
      "original": "   432\t        else:\n   433\t            constraint_name = constraint_names[0]\n   434\t        self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n   435\t\n   436\t    def alter_db_table(self, model, old_db_table, new_db_table):\n   437\t        \"\"\"Rename the table a model points to.\"\"\"\n   438\t        if (old_db_table == new_db_table or\n   439\t            (self.connection.features.ignores_table_name_case and\n   440\t                old_db_table.lower() == new_db_table.lower())):\n   441\t            return\n   442\t        self.execute(self.sql_rename_table % {\n   443\t            \"old_table\": self.quote_name(old_db_table),\n   444\t            \"new_table\": self.quote_name(new_db_table),\n   445\t        })\n   446\t        # Rename all references to the old table name.\n   447\t        for sql in self.deferred_sql:\n   448\t            if isinstance(sql, Statement):\n   449\t                sql.rename_table_references(old_db_table, new_db_table)\n   450\t\n   451\t    def alter_db_tablespace(self, model, old_db_tablespace, new_db_tablespace):\n   452\t        \"\"\"Move a model's table between tablespaces.\"\"\"\n   453\t        self.execute(self.sql_retablespace_table % {\n   454\t            \"table\": self.quote_name(model._meta.db_table),\n   455\t            \"old_tablespace\": self.quote_name(old_db_tablespace),\n   456\t            \"new_tablespace\": self.quote_name(new_db_tablespace),\n",
      "perturbed": "   433\t            constraint_name = constraint_names[0]\n   432\t        else:\n   435\t\n   434\t        self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n   437\t        \"\"\"Rename the table a model points to.\"\"\"\n   439\t            (self.connection.features.ignores_table_name_case and\n   438\t        if (old_db_table == new_db_table or\n   440\t                old_db_table.lower() == new_db_table.lower())):\n   441\t            return\n   443\t            \"old_table\": self.quote_name(old_db_table),\n   442\t        self.execute(self.sql_rename_table % {\n   444\t            \"new_table\": self.quote_name(new_db_table),\n   445\t        })\n   446\t        # Rename all references to the old table name.\n   448\t            if isinstance(sql, Statement):\n   451\t    def alter_db_tablespace(self, model, old_db_tablespace, new_db_tablespace):\n   452\t        \"\"\"Move a model's table between tablespaces.\"\"\"\n   455\t            \"old_tablespace\": self.quote_name(old_db_tablespace),\n   453\t        self.execute(self.sql_retablespace_table % {",
      "applied_operators": [
        "text_perturbation"
      ]
    }
  ]
}