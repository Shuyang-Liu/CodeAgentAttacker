diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py
index b192df4fbf..464d230aef 100644
--- a/django/db/models/fields/related_descriptors.py
+++ b/django/db/models/fields/related_descriptors.py
@@ -652,44 +652,64 @@ def create_reverse_many_to_one_manager(superclass, rel):
                     )
 
         def _apply_rel_filters(self, queryset):
+
             """
+
             Filter the queryset for the instance this manager is bound to.
+
             """
-            db = self._db or router.db_for_read(self.model, instance=self.instance)
-            empty_strings_as_null = connections[
-                db
-            ].features.interprets_empty_strings_as_nulls
-            queryset._add_hints(instance=self.instance)
+
+            # Operate on a clone when possible so we don't mutate the developer
+
+            # provided queryset (it may be reused elsewhere). This also lets us
+
+            # safely clear any slicing limits that would prevent .filter() from
+
+            # being called.
+
+            qs = queryset._chain() if hasattr(queryset, "_chain") else queryset
+
+            # Ensure DB hints are applied to the cloned qs
+
+            try:
+
+                qs._add_hints(instance=self.instance)
+
+            except Exception:
+
+                # If qs doesn't support _add_hints, ignore.
+
+                pass
+
             if self._db:
-                queryset = queryset.using(self._db)
-            queryset._defer_next_filter = True
-            queryset = queryset.filter(**self.core_filters)
-            for field in self.field.foreign_related_fields:
-                val = getattr(self.instance, field.attname)
-                if val is None or (val == "" and empty_strings_as_null):
-                    return queryset.none()
-            if self.field.many_to_one:
-                # Guard against field-like objects such as GenericRelation
-                # that abuse create_reverse_many_to_one_manager() with reverse
-                # one-to-many relationships instead and break known related
-                # objects assignment.
-                try:
-                    target_field = self.field.target_field
-                except FieldError:
-                    # The relationship has multiple target fields. Use a tuple
-                    # for related object id.
-                    rel_obj_id = tuple(
-                        [
-                            getattr(self.instance, target_field.attname)
-                            for target_field in self.field.path_infos[-1].target_fields
-                        ]
-                    )
-                else:
-                    rel_obj_id = getattr(self.instance, target_field.attname)
-                queryset._known_related_objects = {
-                    self.field: {rel_obj_id: self.instance}
-                }
-            return queryset
+
+                qs = qs.using(self._db)
+
+            # Defer the next filter behavior to match original semantics.
+
+            try:
+
+                qs._defer_next_filter = True
+
+            except Exception:
+
+                pass
+
+            # Clear any slice limits on the cloned query to allow filtering.
+
+            try:
+
+                if hasattr(qs, 'query') and hasattr(qs.query, 'clear_limits'):
+
+                    qs.query.clear_limits()
+
+            except Exception:
+
+                # Some QuerySet-like objects may not support clear_limits; continue.
+
+                pass
+
+            return qs._next_is_sticky().filter(**self.core_filters)
 
         def _remove_prefetched_objects(self):
             try:
