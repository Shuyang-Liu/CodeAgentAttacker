diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index aaf35ee37c..04a75a6564 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -840,45 +840,77 @@ class Query(BaseExpression):
             unref_amount = cur_refcount - to_counts.get(alias, 0)
             self.unref_alias(alias, unref_amount)
 
-    def change_aliases(self, change_map):
-        """
-        Change the aliases in change_map (which maps old-alias -> new-alias),
-        relabelling any references to them in select columns and the where
-        clause.
-        """
-        assert set(change_map).isdisjoint(change_map.values())
-
-        # 1. Update references in "select" (normal columns plus aliases),
-        # "group by" and "where".
-        self.where.relabel_aliases(change_map)
-        if isinstance(self.group_by, tuple):
-            self.group_by = tuple([col.relabeled_clone(change_map) for col in self.group_by])
-        self.select = tuple([col.relabeled_clone(change_map) for col in self.select])
-        self.annotations = self.annotations and {
-            key: col.relabeled_clone(change_map) for key, col in self.annotations.items()
-        }
-
-        # 2. Rename the alias in the internal table/alias datastructures.
-        for old_alias, new_alias in change_map.items():
-            if old_alias not in self.alias_map:
-                continue
-            alias_data = self.alias_map[old_alias].relabeled_clone(change_map)
-            self.alias_map[new_alias] = alias_data
-            self.alias_refcount[new_alias] = self.alias_refcount[old_alias]
-            del self.alias_refcount[old_alias]
-            del self.alias_map[old_alias]
-
-            table_aliases = self.table_map[alias_data.table_name]
-            for pos, alias in enumerate(table_aliases):
-                if alias == old_alias:
-                    table_aliases[pos] = new_alias
-                    break
-        self.external_aliases = {
-            # Table is aliased or it's being changed and thus is aliased.
-            change_map.get(alias, alias): (aliased or alias in change_map)
-            for alias, aliased in self.external_aliases.items()
-        }
+        def change_aliases(self, change_map):
+            """
+            Change the aliases in change_map (which maps old-alias -> new-alias),
+            relabelling any references to them in select columns and the where
+            clause. This implementation performs renames in a safe order and
+            can handle overlapping keys and values by using temporary aliases
+            when necessary.
+            """
+            # Work on a copy so we can compute a safe sequence of operations.
+            original_map = change_map.copy()
+            m = change_map.copy()
+            ops = []
+
+            def unique_temp():
+                i = 0
+                while True:
+                    temp = "__dj_tmp_alias_%d" % i
+                    if temp not in self.alias_map and temp not in m and temp not in original_map.values():
+                        return temp
+                    i += 1
+
+            # Build an ordered list of rename operations that avoids double-renames.
+            while m:
+                progress = False
+                for old, new in list(m.items()):
+                    # If the target is not being renamed, we can perform this rename now.
+                    if new not in m:
+                        ops.append((old, new))
+                        del m[old]
+                        progress = True
+                if not progress:
+                    # We've got a cycle. Break it by introducing a temporary alias.
+                    old = next(iter(m))
+                    new = m[old]
+                    temp = unique_temp()
+                    ops.append((old, temp))
+                    # The temporary now points to the original target.
+                    m[temp] = new
+                    del m[old]
+
+            # Apply the rename operations one by one.
+            for old, new in ops:
+                # Update SQL expressions first.
+                self.where.relabel_aliases({old: new})
+                if isinstance(self.group_by, tuple):
+                    self.group_by = tuple([col.relabeled_clone({old: new}) for col in self.group_by])
+                self.select = tuple([col.relabeled_clone({old: new}) for col in self.select])
+                self.annotations = self.annotations and {
+                    key: col.relabeled_clone({old: new}) for key, col in self.annotations.items()
+                }
+
+                # Then update internal alias structures.
+                if old not in self.alias_map:
+                    continue
+                alias_data = self.alias_map[old].relabeled_clone({old: new})
+                self.alias_map[new] = alias_data
+                self.alias_refcount[new] = self.alias_refcount[old]
+                del self.alias_refcount[old]
+                del self.alias_map[old]
+
+                table_aliases = self.table_map[alias_data.table_name]
+                for pos, alias in enumerate(table_aliases):
+                    if alias == old:
+                        table_aliases[pos] = new
+                        break
 
+            # Update external aliases according to the original requested mapping.
+            self.external_aliases = {
+                original_map.get(alias, alias): (aliased or alias in original_map)
+                for alias, aliased in self.external_aliases.items()
+            }
     def bump_prefix(self, outer_query):
         """
         Change the alias prefix to the next letter in the alphabet in a way
