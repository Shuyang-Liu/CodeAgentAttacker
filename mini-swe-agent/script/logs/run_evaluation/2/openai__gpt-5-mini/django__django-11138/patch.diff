diff --git a/django/db/backends/mysql/operations.py b/django/db/backends/mysql/operations.py
index 50f85e0621..1146f3acb8 100644
--- a/django/db/backends/mysql/operations.py
+++ b/django/db/backends/mysql/operations.py
@@ -69,8 +69,32 @@ class DatabaseOperations(BaseDatabaseOperations):
             return "DATE(%s)" % (field_name)
 
     def _convert_field_to_tz(self, field_name, tzname):
+        """
+        Convert a datetime field to the given tzname for SQL queries.
+
+        For backends that don't support time zones (MySQL, SQLite, Oracle),
+        Django stores datetimes in the database timezone configured in the
+        database settings (DATABASES['alias']['TIME_ZONE']) if provided,
+        otherwise in UTC. When USE_TZ is True, convert from the database
+        storage timezone to the requested tzname. If both timezones are the
+        same, avoid applying CONVERT_TZ to keep queries simple (and to avoid
+        requiring populated timezone tables).
+        """
         if settings.USE_TZ:
-            field_name = "CONVERT_TZ(%s, 'UTC', '%s')" % (field_name, tzname)
+            # Prefer a per-database TIME_ZONE setting if provided, falling back
+            # to UTC which is the historical default.
+            source_tz = getattr(self.connection, "timezone", None)
+            if not source_tz:
+                source_tz = self.connection.settings_dict.get('TIME_ZONE', 'UTC')
+            # If source_tz is a tzinfo with a zone attribute, extract its name.
+            if hasattr(source_tz, 'zone'):
+                source_tz_name = source_tz.zone
+            else:
+                source_tz_name = source_tz
+            # If the source and target timezones are identical, no conversion is needed.
+            if source_tz_name == tzname:
+                return field_name
+            field_name = "CONVERT_TZ(%s, '%s', '%s')" % (field_name, source_tz_name, tzname)
         return field_name
 
     def datetime_cast_date_sql(self, field_name, tzname):
diff --git a/django/db/backends/oracle/operations.py b/django/db/backends/oracle/operations.py
index c1afb2ed5e..e800893abe 100644
--- a/django/db/backends/oracle/operations.py
+++ b/django/db/backends/oracle/operations.py
@@ -99,9 +99,21 @@ END;
             return field_name
         if not self._tzname_re.match(tzname):
             raise ValueError("Invalid time zone name: %s" % tzname)
-        # Convert from UTC to local time, returning TIMESTAMP WITH TIME ZONE
-        # and cast it back to TIMESTAMP to strip the TIME ZONE details.
-        return "CAST((FROM_TZ(%s, '0:00') AT TIME ZONE '%s') AS TIMESTAMP)" % (field_name, tzname)
+        # Determine the source (storage) timezone for the database. Prefer a
+        # per-database TIME_ZONE setting if provided, otherwise fall back to UTC.
+        source_tz = getattr(self.connection, "timezone", None)
+        if not source_tz:
+            source_tz = self.connection.settings_dict.get('TIME_ZONE', 'UTC')
+        if hasattr(source_tz, 'zone'):
+            source_tz_name = source_tz.zone
+        else:
+            source_tz_name = source_tz
+        # If source and target are the same, no conversion is needed.
+        if source_tz_name == tzname:
+            return field_name
+        # Convert from the storage timezone to the requested tzname.
+        return "CAST((FROM_TZ(%s, '%s') AT TIME ZONE '%s') AS TIMESTAMP)" % (field_name, source_tz_name, tzname)
+
 
     def datetime_cast_date_sql(self, field_name, tzname):
         field_name = self._convert_field_to_tz(field_name, tzname)
