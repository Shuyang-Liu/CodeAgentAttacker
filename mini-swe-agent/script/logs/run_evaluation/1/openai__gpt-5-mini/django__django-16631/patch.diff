diff --git a/django/contrib/auth/__init__.py b/django/contrib/auth/__init__.py
index 155330c596..a4ab4b332a 100644
--- a/django/contrib/auth/__init__.py
+++ b/django/contrib/auth/__init__.py
@@ -14,6 +14,26 @@ from .signals import user_logged_in, user_logged_out, user_login_failed
 SESSION_KEY = "_auth_user_id"
 BACKEND_SESSION_KEY = "_auth_user_backend"
 HASH_SESSION_KEY = "_auth_user_hash"
+def _session_auth_hash_matches(session_hash, user):
+    """Return True if session_hash matches user's session auth hash
+    using the current SECRET_KEY or any SECRET_KEY_FALLBACKS."""
+    if not session_hash or not hasattr(user, "get_session_auth_hash"):
+        return False
+    # First check against the current key
+    if constant_time_compare(session_hash, user.get_session_auth_hash()):
+        return True
+    # Then check against any fallback secret keys
+    from django.utils.crypto import salted_hmac
+    key_salt = "django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash"
+    for secret in getattr(settings, "SECRET_KEY_FALLBACKS", []):
+        try:
+            candidate = salted_hmac(key_salt, user.password, secret=secret, algorithm="sha256").hexdigest()
+        except Exception:
+            continue
+        if constant_time_compare(session_hash, candidate):
+            return True
+    return False
+
 REDIRECT_FIELD_NAME = "next"
 
 
@@ -106,9 +126,7 @@ def login(request, user, backend=None):
     if SESSION_KEY in request.session:
         if _get_user_session_key(request) != user.pk or (
             session_auth_hash
-            and not constant_time_compare(
-                request.session.get(HASH_SESSION_KEY, ""), session_auth_hash
-            )
+            and not _session_auth_hash_matches(request.session.get(HASH_SESSION_KEY, ""), user)
         ):
             # To avoid reusing another user's session, create a new, empty
             # session if the existing session corresponds to a different
@@ -199,10 +217,7 @@ def get_user(request):
             # Verify the session
             if hasattr(user, "get_session_auth_hash"):
                 session_hash = request.session.get(HASH_SESSION_KEY)
-                session_hash_verified = session_hash and constant_time_compare(
-                    session_hash, user.get_session_auth_hash()
-                )
-                if not session_hash_verified:
+                if not _session_auth_hash_matches(session_hash, user):
                     request.session.flush()
                     user = None
 
